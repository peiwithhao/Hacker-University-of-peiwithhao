# CVE 2017 7308

# 实验环境
+ 主机发行版:ubuntu 16.04LTS
+ kernel: linux-4.10.6
+ config: `CONFIG_PACKET=y`, `CONFIG_USER_NS`, `CONFIG_SLAB=y`, `COFNIG_E1000, CONFIG_E1000E=y`

# AF_PACKET 套接字
这个套接字用来在设备驱动层发送或者接受数据包,这使得用户可以自定义物理层协议
如果要创建这种套接字需要我们在用户命名空间具有`CAP_NET_RAW`权限

我们可以使用`tcpdump`这个工具在某个接口上接受所有的数据包

而进程用来收发数据包则是使用了一个内核创建的缓冲区，然后用户使用mmap来映射到这个缓冲区来进行读写数据

# ring buffer

用户要创建环形缓冲区需要使用结构体`struct tpacket_req3`,用户需要利用这个结构体向setsocketopt系统调用传递信息
而每个数据包会存放在一个单独的帧当中,在`TPACKET_V3`环形缓冲区当中,
帧的大小是变化的


```c
struct tpacket_req3 {
	unsigned int	tp_block_size;	/* Minimal size of contiguous block */	// 每个内存块的大小
	unsigned int	tp_block_nr;	/* Number of blocks */					// 内存块的个数
	unsigned int	tp_frame_size;	/* Size of frame */						// 每个帧的大小，TPACKET_V3会忽视这个字段
	unsigned int	tp_frame_nr;	/* Total number of frames */			// 帧的个数，TPACKET_V3会忽视这个字段
	unsigned int	tp_retire_blk_tov; /* timeout in msecs */				// 超时时间（毫秒），超时后即使内存块没有被数据完全填满也会被内核停用（参考下文）,以便用户能尽快读取数据
	unsigned int	tp_sizeof_priv; /* offset to private data area */		// 每个内存块中私有区域的大小。用户可以使用这个区域存放与每个内存块有关的任何信息；
	unsigned int	tp_feature_req_word;									// 一组标志（目前实际上只有一个标志），可以用来启动某些附加功能。
};
```

而多个帧会被分组为内存块block

┌────────────────────────────────────────────────────────┐
│               block                                    │
│ ┌────────┐  ┌─────────────┐ ┌───────────────────────┐  │
│ │ frame0 │  │frame1       │ │  frame2               │  │
│ └────────┘  └─────────────┘ └───────────────────────┘  │
└────────────────────────────────────────────────────────┘

而每个内存块会拥有一个头部(`struct tpacket_block_desc`)
该内存块会在开头填入这样一个结构体，然后内核将数据包存储到内存块当中，直到他被填充满,然后将内核`block_status`字段设置为`TP_STATUS_USER`,
这表示用户可以从内存块当中读取数据了，当读取完毕后再将`TP_STATUS_KERNEL`,
然后释放内存块，归还给内核使用

```c
struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};
union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};
struct tpacket_hdr_v1 {
	__u32	block_status;			// 标识内存块目前是否正在被内核使用, 能否提供给用户读取
	__u32	num_pkts;
	__u32	offset_to_first_pkt;
	...
};
```
下面就是块的头部


┌───────────────────────────────────────────┐
│       struct tpacket_block_desc           │
│  ┌─────────────────────────────────────┐  │
│  │        tpacket_bd_header_u          │  │
│  │       ┌─────────────────────┐       │  │
│  │       │    block_status     │       │  │
│  │       └─────────────────────┘       │  │
│  └─────────────────────────────────────┘  │
└───────────────────────────────────────────┘


然后帧也存在头部`tpacket3_hdr`,其中的字段`tpacket3_hdr->tp_next_offset`则指向一个内存块中的写一个帧
```c
struct tpacket3_hdr {
	__u32		tp_next_offset;			// 指向同一个内存块中的下一个帧
	__u32		tp_sec;
	__u32		tp_nsec;
	__u32		tp_snaplen;
	__u32		tp_len;
	__u32		tp_status;
	__u16		tp_mac;
	__u16		tp_net;
	/* pkt_hdr variants */
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8		tp_padding[8];
};
```

如下图

            ┌────┐    ┌──────────┐
            │    ▼    │          ▼
      ┌─────┴────┌────┴──────────┌─────────────────┐
      │ frame0   │      frame1   │      frame2     │
      └──────────└───────────────└─────────────────┘



# AF_PACKET 套接字具体实现
每创建一个数据包套接字，内核就会分配一个`packet_sock`结构体

```c
struct packet_sock {
	/* struct sock has to be the first member of packet_sock */
	struct sock		sk;
	struct packet_fanout	*fanout;
	union  tpacket_stats_u	stats;
	struct packet_ring_buffer	rx_ring;			// 接收receive的环形缓冲区，通过setsockopt(..., PACKET_RX_RING, ...)创建。 // ！！！如下
	struct packet_ring_buffer	tx_ring;			// 传输transmit的环形缓冲区，通过setsockopt(..., PACKET_TX_RING, ...)创建。
	...
	enum tpacket_versions	tp_version;				// 环形缓冲区的版本，可通过 setsockopt(..., PACKET_VERSION, ...)设置版本。
	...
	int			(*xmit)(struct sk_buff *skb);
	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
};

// packet_ring_buffer —— https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/internal.h#L56
struct packet_ring_buffer {
	struct pgv		*pg_vec;						// 指向pgv结构体数组的一个指针，数组中的每个元素都保存了对某个内存块的引用。每个内存块实际上都是单独分配的，没有位于一个连续的内存区域中
	...
	struct tpacket_kbdq_core	prb_bdqc;			// 0x30 tpacket_kbdq_core结构体描述了环形缓冲区的当前状态。 // ！！！如下
};
struct pgv {
	char *buffer;
};

// tpacket_kbdq_core —— https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/internal.h#L14
struct tpacket_kbdq_core {
	...
	unsigned short	blk_sizeof_priv;				// 包含每个内存块所属的私有区域的大小。 由用户参数 tpacket_req3->tp_sizeof_priv 传过来, unsigned int -> unsigned short
	...
	char		*nxt_offset;						// 指向当前活跃的内存块的内部区域，表明下一个数据包的存放位置。
	...
	struct timer_list retire_blk_timer;				// timer_list结构体，用来描述超时发生后停用当前内存块的那个计时器
};

// timer_list —— https://elixir.bootlin.com/linux/v4.10.6/source/include/linux/timer.h#L12
struct timer_list {
	struct hlist_node	entry;
	unsigned long		expires;
	void			(*function)(unsigned long);
	unsigned long		data;
	u32			flags;
};
```

