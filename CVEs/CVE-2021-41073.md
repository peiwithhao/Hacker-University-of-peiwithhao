# IORING_OP_PROVIDE_BUFFERS
这个标识位被用来指定传入的SQE的操作类型,具体可以查看man手册,在`io_uring_enter`系统调用中被使用
```c
/*
 * IO submission data structure (Submission Queue Entry)
 */
struct io_uring_sqe {
	__u8	opcode;		/* type of operation for this sqe */
	__u8	flags;		/* IOSQE_ flags */
	__u16	ioprio;		/* ioprio for the request */
	__s32	fd;		/* file descriptor to do IO on */
    .......
}
```
这个命令用来在在用户层注册一个缓冲区组用来读取/接受数据,使用该操作可以用来消除poll+read的割裂感

这里的poll系统调用是一种IO多路复用机制,是被用来告知内核来监控文件的变化然后通知用户进行处理,而不是用户IO后发现文件暂时不可操作而进行阻塞,这样极大提升了工作效率

让我们再说回`IORING_OP_PROVIDE_BUFFEERS`,这个io_uring_sqe所代表的操作将允许用户能够拥有内核中已经就绪的缓存池,当文件或者套接字准备好被读取/被接受数据,一个缓冲区将被选中来做该项操作

这些被创造的缓冲区通过group ID来管理,当提交一个请求,用户通过设置`IOSQE_BUFFER_SELECT`指定一个提供的缓冲区并且指定groupID
当操作完成,groupID的缓冲区将被作为CQE来返回给用户

而要搞清楚这个操作符干了什么,最好的办法也就是自己看一遍源码
这里我们可以从`io_uring_enter()`看起,直到函数`io_issue_sqe()`

```c
    ...
	case IORING_OP_PROVIDE_BUFFERS:
		ret = io_provide_buffers(req, issue_flags);
		break;
    ...

```
该函数通过`struct io_uring_sqe`结构体当中的opcode来判断操作,最终调用`io_provide_buffers()`函数

```c

static int io_provide_buffers(struct io_kiocb *req, unsigned int issue_flags)
{
    ...

	ret = io_add_buffers(p, &head);
    ...

	return 0;
}


static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)
{
	struct io_buffer *buf;
	u64 addr = pbuf->addr;
	int i, bid = pbuf->bid;

	for (i = 0; i < pbuf->nbufs; i++) {
		buf = kmalloc(sizeof(*buf), GFP_KERNEL_ACCOUNT);
		if (!buf)
			break;

		buf->addr = addr;
		buf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);
		buf->bid = bid;
		addr += pbuf->len;
		bid++;
		if (!*head) {
			INIT_LIST_HEAD(&buf->list);
			*head = buf;
		} else {
			list_add_tail(&buf->list, &(*head)->list);
		}
		cond_resched();
	}

	return i ? i : -ENOMEM;
}

```
可以看到当我们使用该操作类型来发起`io_uring_enter`系统调用提交sqe的时候,内核会调用`io_provide_buffers()`每个buffer分配`struct io_buffer`,他们之间通过`struct list_head`进行连接

```c
struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
};
```



