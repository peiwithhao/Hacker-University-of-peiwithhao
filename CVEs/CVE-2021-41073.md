# io_provide_buffers
这个标识位被用来指定传入的SQE的操作类型,具体可以查看man手册,在`io_uring_enter`系统调用中被使用
```c
/*
 * IO submission data structure (Submission Queue Entry)
 */
struct io_uring_sqe {
	__u8	opcode;		/* type of operation for this sqe */
	__u8	flags;		/* IOSQE_ flags */
	__u16	ioprio;		/* ioprio for the request */
	__s32	fd;		/* file descriptor to do IO on */
    .......
}
```
这个命令用来在在用户层注册一个缓冲区组用来读取/接受数据,使用该操作可以用来消除poll+read的割裂感

这里的poll系统调用是一种IO多路复用机制,是被用来告知内核来监控文件的变化然后通知用户进行处理,而不是用户IO后发现文件暂时不可操作而进行阻塞,这样极大提升了工作效率

让我们再说回`IORING_OP_PROVIDE_BUFFEERS`,这个io_uring_sqe所代表的操作将允许用户能够拥有内核中已经就绪的缓存池,当文件或者套接字准备好被读取/被接受数据,一个缓冲区将被选中来做该项操作

这些被创造的缓冲区通过group ID来管理,当提交一个请求,用户通过设置`IOSQE_BUFFER_SELECT`指定一个提供的缓冲区并且指定groupID
当操作完成,groupID的缓冲区将被作为CQE来返回给用户

而要搞清楚这个操作符干了什么,最好的办法也就是自己看一遍源码
这里我们可以从`io_uring_enter()`看起,直到函数`io_issue_sqe()`

```c
    ...
	case IORING_OP_PROVIDE_BUFFERS:
		ret = io_provide_buffers(req, issue_flags);
		break;
    ...

```
该函数通过`struct io_uring_sqe`结构体当中的opcode来判断操作,最终调用`io_provide_buffers()`函数

```c

static int io_provide_buffers(struct io_kiocb *req, unsigned int issue_flags)
{
    ...

	ret = io_add_buffers(p, &head);
    ...

	return 0;
}


static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)
{
	struct io_buffer *buf;
	u64 addr = pbuf->addr;
	int i, bid = pbuf->bid;

	for (i = 0; i < pbuf->nbufs; i++) {
		buf = kmalloc(sizeof(*buf), GFP_KERNEL_ACCOUNT);
		if (!buf)
			break;

		buf->addr = addr;
		buf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);
		buf->bid = bid;
		addr += pbuf->len;
		bid++;
		if (!*head) {
			INIT_LIST_HEAD(&buf->list);
			*head = buf;
		} else {
			list_add_tail(&buf->list, &(*head)->list);
		}
		cond_resched();
	}

	return i ? i : -ENOMEM;
}

```
可以看到当我们使用该操作类型来发起`io_uring_enter`系统调用提交sqe的时候,内核会调用`io_provide_buffers()`每个buffer分配`struct io_buffer`,他们之间通过`struct list_head`进行连接

```c
struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
};
```

# io_rw
当我们提交的SQE中opcode为`IO_OP_READ|IO_OP_READV|IO_OP_READ_FIXED|IO_OP_WRITE|IO_OP_WRITEV|IO_OP_WRITE_FIXED`时,就会调用io_rw类似函数,例如`io_read/write`

如果我们发起的请求当中包含IOSQE_BUFFER_SELECT的时候,在内核源码中该标识符被设置于`struct io_uring_sqe(__u32 opcode)`当中

当该标识符设置时,内核在真正执行io_*函数来处理IO操作时,会查看是否为rw操作,
若是则再检查提交是否含有`IOSQE_BUFFER_SELECT`标识位(或是`REQ_F_BUFFER_SELECT`,这里两者在io_uring.c中的一个枚举类型中划了等号)则会首先调用`io_rw_buffer_select()`

```c
static void __user *io_rw_buffer_select(struct io_kiocb *req, size_t *len,
					bool needs_lock)
{
	struct io_buffer *kbuf;
	u16 bgid;

	kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;
	bgid = req->buf_index;
	kbuf = io_buffer_select(req, len, bgid, kbuf, needs_lock);
	if (IS_ERR(kbuf))
		return kbuf;
	req->rw.addr = (u64) (unsigned long) kbuf;
	req->flags |= REQ_F_BUFFER_SELECTED;
	return u64_to_user_ptr(kbuf->addr);
}
```

这里发现存在些许的问题,因为我们`req->rw.addr = (u64)(unsigned long)kbuf` 
这里我们本该存储用户区域读写地址的字段给赋值为内核区域io_buffer的地址,
一般同一个字段在不同时间段存在内核或用户地址总是会出现混淆的问题,这也引出了一个漏洞点

# 漏洞点
这里介绍一个内核函数`loop_rw_iter()`
```c
/*
 * For files that don't have ->read_iter() and ->write_iter(), handle them
 * by looping over ->read() or ->write() manually.
 */
static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)
{
	struct kiocb *kiocb = &req->rw.kiocb;
	struct file *file = req->file;
	ssize_t ret = 0;

	/*
	 * Don't support polled IO through this interface, and we can't
	 * support non-blocking either. For the latter, this just causes
	 * the kiocb to be handled from an async context.
	 */
	if (kiocb->ki_flags & IOCB_HIPRI)
		return -EOPNOTSUPP;
	if (kiocb->ki_flags & IOCB_NOWAIT)
		return -EAGAIN;

	while (iov_iter_count(iter)) {
		struct iovec iovec;
		ssize_t nr;

		if (!iov_iter_is_bvec(iter)) {
			iovec = iov_iter_iovec(iter);
		} else {
			iovec.iov_base = u64_to_user_ptr(req->rw.addr);
			iovec.iov_len = req->rw.len;
		}

		if (rw == READ) {
			nr = file->f_op->read(file, iovec.iov_base,
					      iovec.iov_len, io_kiocb_ppos(kiocb));
		} else {
			nr = file->f_op->write(file, iovec.iov_base,
					       iovec.iov_len, io_kiocb_ppos(kiocb));
		}

		if (nr < 0) {
			if (!ret)
				ret = nr;
			break;
		}
		ret += nr;
		if (nr != iovec.iov_len)
			break;
		req->rw.len -= nr;
		req->rw.addr += nr;
		iov_iter_advance(iter, nr);
	}

	return ret;
}
```
正如其注释所说,当一个file文件没有实现`read_iter()`和`write_iter`时将会调用它,但是我们注意到最后几行
也就是`req->rw.addr += nr;`,可以看到对于我们上面提到的值加上了nr

然后我们这里为了举例因此查看`io_read()`函数,这个函数在我们提交SQE中的opcode为`IO_OP_READ|IO_OP_READV|IO_OP_WRITE_FIXED`时会进行调用,调用链条如下:

```
io_read()
    io_import_iovec()
        io_iov_buffer_select()
            __io_iov_buffer_select()
                io_rw_buffer_select()       #如果有REQ_F_BUFFER_SELECT,则req->rw.addr被设置为一个内核buffer的地址
        kiocb_done()
            io_put_rw_kbuf()
                io_put_kbuf()               #kfree
```

给出`io_put_kbuf()`函数
```c
static unsigned int io_put_kbuf(struct io_kiocb *req, struct io_buffer *kbuf)
{
	unsigned int cflags;

	cflags = kbuf->bid << IORING_CQE_BUFFER_SHIFT;
	cflags |= IORING_CQE_F_BUFFER;
	req->flags &= ~REQ_F_BUFFER_SELECTED;
	kfree(kbuf);
	return cflags;
}


static inline unsigned int io_put_rw_kbuf(struct io_kiocb *req)
{
	struct io_buffer *kbuf;

	kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;
	return io_put_kbuf(req, kbuf);
}

```
我们可以看到在`io_put_rw_kbuf()`函数赋值`kbuf = req->rw.addr`
而这里注意一点如果我们的SQE中的flags字段带有`IOSQE_BUFFER_SELECT`,那么此时的`req->rw.addr`字段就是一个内核地址
所以此时`io_put_kbuf()`函数中`kfree(kbuf)`就等同于`kfree(req->rw.addr)`
因此如果我们在io_read()函数中调用的是`loop_rw_iter()`,那么就可以修改这个req->rw.addr的值,而且这还可以是一个内核地址,然后最后io_read退出时调用到的`io_put_kbuf`就可以实现任意地址释放的功能
`kfree(req->rw.addr + user_controlled_value);`

# 漏洞利用
