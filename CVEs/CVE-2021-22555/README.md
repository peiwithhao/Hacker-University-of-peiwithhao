# CVE-2021-22555 
受影响版本范围:Linux v2.6.19-rc1~v5.12-rc7 
v5.12-rc8已经修复
5.12，5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267已经修复

# 实验环境
kernel: Linux-5.10.23
rootfs: busybox latest
config: 所有`CONFIG_IP_NF_**, CONFIG_NETFILTER_**`,`CONFIG_E1000, CONFIG_E1000E`

# 漏洞点
`net/netfilter/x_tables.c: xt_compat_match_from_user()`
需要`CAP_NET_ADMIN`权限，或者支持`user+network`命名空间
在该函数当中存在内核结构转换的过程中由于错误计算转换大小可能导致`off by null`

触发函数链条
```
setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, ...)
    nf_setsockopt()
        do_ipt_set_ctl()
            compat_do_replace()
                translate_compat_table()
                    compat_copy_entry_from_user()
                        xt_compat_match_from_user() & xt_compat_target_from_user()
```
这里主要聚焦于`ip_tables`这样一个防火墙实现的部分
主要了解一下各个函数所做的主要功能
```c
/* setsockopt的回调函数 */
static int
do_ipt_set_ctl(struct sock *sk, int cmd, sockptr_t arg, unsigned int len)
{
    ...
	switch (cmd) {
	case IPT_SO_SET_REPLACE:     //我们索要使用的cmd参数
#ifdef CONFIG_COMPAT
		if (in_compat_syscall())
			ret = compat_do_replace(sock_net(sk), arg, len);
		else
        ...
}


static int
compat_do_replace(struct net *net, sockptr_t arg, unsigned int len)
{
    ...
	struct compat_ipt_replace tmp;
	struct xt_table_info *newinfo;
	void *loc_cpu_entry;
	struct ipt_entry *iter;

    /* 拷贝arg.user 到 struct compat_ipt_replace tmp 当中*/
	if (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)
		return -EFAULT;
    ...

	tmp.name[sizeof(tmp.name)-1] = 0;

    /* 通过tmp.size分配新的 xt_table_info */
    /* 这里需要记住struct xt_table_info使用kvmalloc进行分配，分配标志为KERNEL_ACCOUNT */
	newinfo = xt_alloc_table_info(tmp.size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
    /* 向new xt_table_info偏移为compat_ipt_replace的起始地址开始复制内容 */
    /* 实际上就是分配entries数 */
	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
			tmp.size) != 0) {
		ret = -EFAULT;
		goto free_newinfo;
	}

	ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);
    ...
}

/* 构造新的xt_table_info */
static int
translate_compat_table(struct net *net,
		       struct xt_table_info **pinfo,
		       void **pentry0,
		       const struct compat_ipt_replace *compatr)
{
	unsigned int i, j;
	struct xt_table_info *newinfo, *info;
	void *pos, *entry0, *entry1;
	struct compat_ipt_entry *iter0;
	struct ipt_replace repl;
	unsigned int size;
	int ret;

	info = *pinfo;
	entry0 = *pentry0;
	size = compatr->size;
	info->number = compatr->num_entries;
    ...
    /* 又分配了新的xt_table_info用来做兼容性替换 */
	newinfo = xt_alloc_table_info(size);
	if (!newinfo)
		goto out_unlock;

	newinfo->number = compatr->num_entries;
	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
		newinfo->hook_entry[i] = compatr->hook_entry[i];
		newinfo->underflow[i] = compatr->underflow[i];
	}
	entry1 = newinfo->entries;
	pos = entry1;
	size = compatr->size;
	xt_entry_foreach(iter0, entry0, compatr->size) //开始拷贝entry
		compat_copy_entry_from_user(iter0, &pos, &size,
					    newinfo, entry1);
    ...
}

/* 旧的xt_table_info 拷贝到新的xt_table_info */
static void
compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
			    unsigned int *size,
			    struct xt_table_info *newinfo, unsigned char *base)
{
	struct xt_entry_target *t;
	struct ipt_entry *de;
	unsigned int origsize;
	int h;
	struct xt_entry_match *ematch;

	origsize = *size;
	de = *dstptr;
	memcpy(de, e, sizeof(struct ipt_entry));
	memcpy(&de->counters, &e->counters, sizeof(e->counters));

	*dstptr += sizeof(struct ipt_entry);
	*size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);

	xt_ematch_foreach(ematch, e)
		xt_compat_match_from_user(ematch, dstptr, size);

	de->target_offset = e->target_offset - (origsize - *size);
	t = compat_ipt_get_target(e);
	xt_compat_target_from_user(t, dstptr, size);

	de->next_offset = e->next_offset - (origsize - *size);

	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if ((unsigned char *)de - base < newinfo->hook_entry[h])
			newinfo->hook_entry[h] -= origsize - *size;
		if ((unsigned char *)de - base < newinfo->underflow[h])
			newinfo->underflow[h] -= origsize - *size;
	}
}
```






















