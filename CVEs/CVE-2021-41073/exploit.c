#include <stdio.h>
#include <liburing.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define QUEUE_DEPTH 0x800

int group_v1 = 0x114514;
int group_v2 = 0xdeadbeef;

char buf_v1[0x1000][0x100] = {0};
char buf_v2[0x1000][0x100] = {0};

void failure(char * msg){
    perror(msg);
    exit(1);
}


struct io_uring ring = {0};
struct io_uring_params uring_params = {0};



void io_uring_playground(){
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;

    printf("[^v^]Stage I:\n");
    printf("[*]Tryinng to initialize the io_uring...\n");
    /* 实现和io_uring_queue_init()类似,只不过这里传递的参数不同罢了 */
    if(io_uring_queue_init_params(QUEUE_DEPTH, &ring, &uring_params) != 0){
        printf("[x]Initialize the io_uring failed...\n");
        exit(1);
    }
    printf("[+]Initialize the io_uring successfully!\n");
   


    printf("[^v^]Stage II:\n");
    printf("[*]Trying to spray the kmalloc-32 with io_buffer...\n");
    sqe = io_uring_get_sqe(&ring);
    /* 让内核分配1000个struct io_buffer 结构体*/
    /* 经过计算一个kmalloc-32通用内存的slab是一个page大小,也就是说可以容纳128个io_buffer */
    io_uring_prep_provide_buffers(sqe, buf_v1, 0x100, 1000, group_v1, 0);
    io_uring_submit(&ring);
    /* 等待上面的堆喷事件的结束 */
    io_uring_wait_cqe(&ring, &cqe);
    /* 这里是为了告知内核这个cqe已经被处理过了,适当清理空间 */
    io_uring_cqe_seen(&ring, cqe);
    /* 这里的字段是返回的结果状态code */
    if(cqe->res < 0){
        printf("[x]spary the io_buffer failed...");
        exit(1);
    }


    
     
    // io_uring_prep_provide_buffers(sqe, buf_v1, 0x100, 1000, group_v1, 0);


}


int main(void){
    io_uring_playground(); 
}

