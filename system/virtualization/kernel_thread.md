# 内核线程
内核线程的创建都来自于`kthreadd`,他一般是pid2进程

不同于进程，在内核中创建进程都会涉及到`copy_process()`,而这个函数会拷贝父进程的内容，
并且之后创建的进程就拥有了自己的进程空间,
但是内核线程们都共享同一个地址空间,也就是整个内核空间


# kthreadd
内核线程的生产者，他在`rest_init()`函数里面通过`kernel_thread()`来创建,这个函数里面实际上也会调用`copy_process()`,
只不过传递的PID为NULL

而该内核线程的主要工作就是
1. 首先阻塞自身，等待唤醒
2. 遍历内核全局链表`kthread_create_list`,然后从中遍历看是否有需要唤醒的条目，
3. 如果遍历到了就调用`create_thread()`,这里的`create_thread()`会调用之前的`kernel_thread()`来创建内核线程所需要的task
4. 这个全局链表遍历完毕则再次阻塞自己等待唤醒

而唤醒这个`kthreadd`进程则就需要普通的内核代码调用`kthread_create_on_node()`等函数进行调用



# 可能的问题
现在可以知道的情报有:
1. 内核线程共享内核内存空间
2. 内核线程由`copy_process(NULL, **)`,其cgroups等资源限制共享内核

因此如果说有受到cgroups限制用户进程通过调用链条能唤醒某个内核线程，那么就将导致**内核的额外消耗**


# 列表






