# Linux 伪文件系统
仅存在于内存当中的文件系统,在runc初始化容器过程中将为容器所在的`mount namespace`挂载procfs和sysfs

## procfs
提供一种访问内核数据结构和运行时系统信息的方式，
可以通过查看该文件系统下各类文件来访问系统内存的使用情况和统计信息，
其输出的动作由内核中的各个伪文件所绑定的回调函数完成，对应内核回调函数可对文件读取进程所属的命名空间进行检查，
从而输出对应命名空间的系统信息从而实现伪文件的容器化隔离

而procfs同样包含一类`ctl_table`信息,对应`/proc/sys`目录下的文件，每个文件内容一般对应一个内核参数全局变量
文件内容可以通过sysctl内核参数修改工具来更改

## sysfs
该文件系统主要用于呈现系统设备和驱动程序信息,
使得用户和应用程序可以方便的访问和管理系统中的硬件设备。
sysfs的核心为kobject结构体,其中包含内核对象的属性，而Kobject可用于管理设备、驱动程序、总线、类别等各种内核对象
用户空间可以通过sysfs文件系统接口读取和修改kobject属性值，也可以通过sysfs中的文件触发特定操作。
sysfs提供两种判断文件是否可见：
1. 属性组文件所在的kobject的namespace
2. 属性组文件的`is_visible`机制，该机制用于确定该属性组文件是否对用户空间可见

# SystemTap内核观测
开源系统调试和性能分析工具,可用于监控和跟踪Linux内核活动，从而帮助开发者诊断性能问题、调试内核模块、分析系统行为
其使用一种专门的脚本语言，提供丰富的API和语法，用于描述要观测的事件、条件和动作。工作原理是将脚本翻译为C,编译为内核模块，然后通过内核钩子来激活探测点,
会话停止后自动移除内核模块


# 需求性分析
1. Linux namespace技术晚于伪文件系统
2. 命名空间仅能够隔离有限种类的系统资源

## 伪文件信息收集
通过IR进行扫描，所收集信息如下：
1. 伪文件注册点调用信息
2. 路径信息：目标在文件系统中的完整路径
3. 伪文件回调函数：读取所分析目标伪文件过程将调用的一系列内核回调函数
4. 伪文件数据源信息：读取所分析伪文件时将输出的内核变量

## 伪文件隔离性分析
主要用来识别目标伪文件是否使用Linux namespace来进行隔离，用以下角度来判断
1. 伪文件内核回调函数隔离性：从Linux文件open,read两阶段调用过程是否存在命名空间隔离机制的使用
2. 伪文件数据源隔离性：对于可以通过伪文件注册函数参数传入伪文件数据源的情况，判断所传入数据源参数是否被Linux namespace命名空间隔离，
包括直接从Linux命名空间变量值取值或间接受到Linux命名空间变量影响
3. 伪文件内置隔离机制的使用：检查是否内置隔离机制，包含文件注册位置以及伪文件可见性检查

## 伪文件可利用分析
如果检测到未隔离伪文件，则进一步分析其可利用性
1. 内核资源DoS：检测文件是否暴露内核资源计数器类型变量，可利用其观测并耗尽内核资源变量
2. 判断容器同驻利用：检测该未隔离伪文件所暴露变量是否可作为宿主机指纹类变量，攻击者可利用此伪文件进行判断多个容器是否被部署于同一宿主机
3. 容器逃逸利用：检测文件所暴露的数据源是否与容器逃逸常用内核机制相关，攻击者可以利用此伪文件发起容器逃逸攻击

# 系统设计

1. 扫描阶段：内核编译IR,opt加载Pass来收集伪文件信息，从而获得所分析的伪文件目标对应的注册点上下文、文件路径、回调函数、所暴露内核数据源等信息，
格式化后返回给分析阶段
2. 分析阶段：根据扫描阶段的信息来识别伪文件系统中的隔离情况,并且判断伪伪恩恩见中存在隔离机制的具体数据源情况

## 伪文件信息收集
### 伪文件注册点上下文收集
注册点上下文，可能包含伪文件名称，所在目录信息，伪文件回调信息等等
1. 搜索注册函数，获取上下文信
2. 搜索注册函数的引用，得出所有传递给注册函数的实参
3. 将搜集到的信息保存在伪文件注册调用实例集合中 

### 伪文件路径信息收集
重点在于目录的收集
1. 收集所有目录注册函数实例，并获取其被调用语句，还有注册目录所在父目录信息
2. 将目录路径信息、所在父目录信息保存在伪文件目录父子表中，
3. 当对伪文件注册函数的调用实例进行分析时取出所传递的目录变量，然后查询父子表，直到获取其完整路径

### 伪文件回调函数收集

```c
static const struct file_operations proc_sys_file_operations = {
	.open		= proc_sys_open,
	.poll		= proc_sys_poll,
	.read_iter	= proc_sys_read,
	.write_iter	= proc_sys_write,
	.splice_read	= generic_file_splice_read,
	.splice_write	= iter_file_splice_write,
	.llseek		= default_llseek,
};

static const struct file_operations proc_sys_dir_file_operations = {
	.read		= generic_read_dir,
	.iterate_shared	= proc_sys_readdir,
	.llseek		= generic_file_llseek,
};

static int proc_sys_open(struct inode *inode, struct file *filp)
{
    ...
}
```

1. 从注册点上下文保存的函数参数中取出注册的文件操作函数实例，包括open和read函数指针
2. open阶段直接将所注册的VFS文件操作接口中的 open 指针作为 open 阶段回调函数收集结果，
在此回调函数中，内核将为文件准备后续打开时所需的指针内容，或文件子类型内
容（如序列文件的序列读取回调函数、数据等）。
3. open阶段对文件子类型进行分析，检查是否设置了子类型操作回调，如果实际子类型回调函数传递至read,
则将其子类型回调函数的read作为收集结果，如果没有则直接将VFS文件操作接口中的read指针作为收集结果

### 伪文件数据源信息收集
1. 遍历注册上下文集合，获取伪文件回调函数
2. 如果是通用函数变量，则存入伪文件信息结构体
3. 如果是非通用的自定义函数，则需要遍历read回调函数中的函数调用语句，检查其是否是文件输出函数，过滤掉无用信息后对其回溯寻找元数据
4. 当回调结束后，检查其起点是否为伪文件系统自定义数据结构，如果是自定义数据指针，则将注册上下文对应数据源写入伪文件信息结构体，否则就直接写入
取出输出变量存入文件信息结构体

## 伪文件隔离性分析
### 回调函数
1. 判断open是否存在对于进程以及命名空间的限制
2. 判断read在读取内容中是否存在命名空间切换的操作

### 伪文件内核数据源隔离分析
1. 寻找由注册函数参数传递的数据源
2. 使用`def-use`遍历数据使用者集合,检查是否有对内核数据源参数的存值操作,主要是找到该变量的原始赋值
3. 如果最终的内核数据源是从进程命名空间读出则被视为隔离

### 伪文件内置隔离机制
1. 伪文件注册位置：调用伪文件注册函数时所传入的伪文件目录参数变量,目录参数允许来自Linux命名空间类型变量，这样就造成了隔离
2. 伪文件可见性检查：首先获取伪文件注册函数调用时待注册的伪文件内核对象，判断其中的可见性判断函数指针是否伪空指针,
若非空则取出该函数来遍历其中指令是否存在操作数伪Linux 命名空间变量,碰到函数调用则步入检查

## 伪文件可利用性分析
### 内核资源DoS
对未隔离伪文件包含的内核变量进行遍历，通过`def-use`检查该变量在内核中的使用情况，
检查是否存在自增和比较，且比较操作的结果用于进行条件跳转。若存在则判断可以发起DoS攻击

### 容器同驻利用
使用内核观测方法，判断未隔离伪文件所共享内核变量是否具有短时间静态特点，将其作为指纹变量标记宿主机为容器同驻的判断依据
1. 遍历未隔离伪文件所暴露的内核全局变量信息，将其以伪文件-全局变量存入表中
2. 在各信息一致的多台宿主机使用SystemTap内核观测工具对列表变量进行观测，获取统一内核全局变量所保存的内容。取出其中内容未发生改变的变量存入短时不变的内核变量集合。
3. 然后取出不同宿主机保存的短时不变变量，讲起视为指纹类共享内核变量

### 容器逃逸利用
利用`usermodehelper`机制
用户通过识别未隔离伪文件所共享内核全局变量是否被作为`usermodehelper`机制中自定义处理程序路径并提供写入操作来进行判断
1. 从`usermodehelper`机制中的特征函数`call_usermodehelper_setup()`来分析,第1各参数为所注册的自定义处理程序路径，系统将分析该路径参数是否暴露给未隔离伪文件
2. 对该参数进行回溯，判断`def-use`链条是否存在存值操作，若存在则继续向上回溯
3. 回溯的过程中如果节点到达内核全局变量则停止回溯,记录内核全局变量为可用于容器逃逸利用的全局变量点
4. 完成全局变量收集后则遍历未隔离伪文件中所包含的内核变量，若查询到对应变量则说明有逃逸风险
5. 对具有逃逸风险的变量进一步进行可写性分析,当可写检查通过则标记该未隔离伪文件能用于发起容器逃逸



