# 可信启动
什么是可信启动?

下面是x86_64架构启动流程
![架构启动流程](http://kafroc.github.io/assets/img/2020-05-17-01.png)

一般步骤就是设置CPU,然后CPU加载BIOS代码到内存当中，然后BIOS代码将加载bootloader来加载内核到内存


而可信启动有两个关键点:可信根和可信链

而可信这个可以类比主机要访问一个远端的https链接,
客户端需要验证访问的远端主机的根CA是否被客户端所信任,
还需要查看根CA到远端证书的链条是否完整

要实现可信启动，首先需要 cpu 的支持，其次还需要 TPM（Trusted Platform Module）芯片的支持，
TPM 有两个作用，作用一：提供加解密算法的支持，
作用 二：存储对称密钥及私钥。
可能部分嵌入式产品还需要 OTP（One Time Programmable）芯片。

可信启动所涉及的关键技术如下:
+ TPM: 提供加密密钥的存储、随机数生成、平台完整性测量的功能
+ PCR(Platform Configuration Registers): TPM中用于存储系统状态的寄存器,
用于记录启动过程中加载的组件的hash

而在启动过程中涉及到的核心概念如下:
+ 测量: 将启动组件的Hash计算后放置到PCR中
+ 验证: 通过对比记录的hash值和预期值来验证组件的完整性

# 可信启动基本流程
在x86_64架构下，可信启动流程通常分为以下几个阶段：

1. 平台初始化阶段
    + 在系统加电后，BIOS或UEFI初始化硬件。
    + BIOS/UEFI配置TPM并将其置为活动状态。
    + 将BIOS/UEFI自身的哈希值计算并记录到TPM的PCR中（通常是PCR 0）。
    + 如果支持Intel TXT，BIOS会初始化TXT硬件支持。
2. 启动测量阶段
    + 测量BIOS/UEFI配置：
        + BIOS/UEFI会测量其启动配置和执行路径，将其哈希值写入PCR 1。
    + 测量启动加载器（Bootloader）：
        + BIOS/UEFI将启动加载器（如GRUB）的哈希值计算后存入PCR 2。
    + 测量操作系统内核：
        + 启动加载器测量操作系统内核的哈希值并将其写入PCR 3。
    + 测量内核模块和初始化文件：
        + 内核加载时测量关键模块、驱动程序和初始RAM盘（initrd/initramfs）的哈希值，记录到PCR 4、PCR 5等。
3. 启动验证阶段
+ 启动完成后，系统可使用TPM模块中的PCR值进行验证。
+ 验证可以由远程平台（如云管理平台）或本地平台执行：
    + 本地验证：通过本地策略对PCR值进行对比，确保未被篡改。
    + 远程证明（Remote Attestation）：系统向远程服务器发送TPM签名的PCR值，远程服务器验证其合法性。

# 可信启动检验流程的优化
可信启动的校验时间较长，通常是由于启动过程中的测量和验证操作需要计算大量的哈希值和对比操作（如PCR验证）。尤其是在文件量较大或系统复杂的场景下，这个问题会更加突出。

## 一、优化可信启动校验的常见方法
1. 减少需要校验的对象
+ 问题：可信启动会测量多个组件，包括BIOS、Bootloader、Kernel、Initrd、内核模块和系统关键文件。组件越多，校验时间越长。
+ 优化方法：
    + 分层校验：
        + 将可信启动分为多个阶段，只对关键阶段进行深度校验。
        + 例如，仅测量Bootloader和操作系统内核，而跳过其他阶段的细节（如内核模块）。
    + 动态加载测量：
        + 只测量系统启动时必须加载的关键模块，延后非关键模块的测量（如非必要驱动程序）。
        + 使用按需校验（Lazy Measurement），在模块实际被加载时再进行测量。
+ 应用场景：
    + 嵌入式设备或物联网设备，启动时只需要少量模块。
    + 系统安全策略允许非关键模块延后校验。
2. 并行化校验操作
+ 问题：传统校验流程是串行的，即每个组件依次测量并记录PCR值，这会延长整体校验时间。
+ 优化方法：
    + 多线程测量：
        + 将多个模块的哈希计算并行化，利用多核CPU的计算能力。
        + 例如，在测量内核模块和RAM盘内容时，分配多个线程同时处理。
    + 硬件加速：
        + 使用支持并行加密/哈希计算的硬件加速器（如Intel QAT）。
        + TPM 2.0硬件本身通常支持更快的PCR扩展操作。
+ 应用场景：
    + 数据中心服务器、大规模虚拟化环境，硬件资源较为丰富。
    + 高性能计算场景中对启动速度要求较高。
3. 缓存优化
+ 问题：每次启动时，可信启动从头开始测量和校验所有组件，重复计算相同的哈希值，浪费时间。
+ 优化方法：
    + 状态缓存：
        + 在TPM外部记录上一次启动的测量状态（如文件的哈希值）。
        + 在文件未发生更改时，直接使用缓存值而不重新计算。
    + 增量校验：
        + 仅测量和校验发生更改的组件（如内核版本更新后，只校验更新部分）。
        + 可以结合文件系统的时间戳和校验码，快速定位需要重新测量的部分。
+ 应用场景：
    + 桌面操作系统和服务器，文件和模块更新频率较低。
    + 针对重复启动的设备，如嵌入式设备。
4. 改进哈希算法
+ 问题：传统的可信启动常使用SHA-256或SHA-1进行测量，这些算法的计算开销较大。
+ 优化方法：
    + 轻量级哈希算法：
        + 使用优化版本的SHA算法（如SHA-3或BLAKE2b），提升计算效率。
    + 硬件支持的哈希计算：
        + 现代CPU（如Intel或AMD处理器）通常支持硬件指令集加速哈希计算，例如Intel SHA Extensions。
        + 利用TPM 2.0的硬件哈希单元，直接在TPM中完成哈希计算。
+ 应用场景：
    + 对性能要求较高的场景，如云计算节点启动。
5. TPM模块的性能优化
+ 问题：TPM的PCR操作和签名计算较慢，特别是TPM 1.2版本，其吞吐量有限。
+ 优化方法：
    + 升级到TPM 2.0：
        + TPM 2.0相比TPM 1.2提供更高的吞吐量和更灵活的PCR操作。
        + TPM 2.0支持多个并行操作和更高的哈希计算速度。
    + 减少PCR写入次数：
        + 使用更少的PCR寄存器，合并测量值，减少PCR扩展操作。
        + 例如，将多个文件的哈希值结合后，计算一个合成哈希值再写入PCR。
    + 离线测量：
        + 将测量操作移至启动前的阶段，在启动后直接验证测量结果。
+ 应用场景：
    + 老旧硬件升级到TPM 2.0后，显著提升启动效率。
6. 延迟验证（Post-boot Validation）
+ 问题：完整的可信启动校验会显著延长启动时间，尤其是在模块数量较多的情况下。
+ 优化方法：
    + 允许系统先完成启动，然后在后台逐步验证非关键组件:
        + 例如，内核启动后，可以后台校验内核模块和文件系统完整性。
+ 应用场景：
    + 启动时间敏感的设备（如智能手机）。
    + 非关键模块对系统运行安全影响较小的场景。
7. 分布式证明
+ 问题：单机完成所有测量和校验需要消耗大量资源，时间较长。
+ 优化方法：
    + 在云计算环境中，将测量和校验操作分布到多个节点:
        + 例如，在虚拟化平台中，主机负责测量虚拟机的关键组件，而虚拟机仅校验自身环境。
+ 应用场景：
    + 大规模数据中心或云平台。
## 二、典型优化方案示例
以下是结合以上方法的一些实际案例：

+ 谷歌Titan芯片：
    + 谷歌通过自研的Titan安全芯片（类似于TPM）优化其服务器启动流程，利用定制硬件和缓存机制，显著减少启动时间。
+ Linux IMA/EVM架构：
    + 使用延迟校验和分层校验机制，仅对关键文件进行实时校验。
+ tboot改进：
    + Intel tboot项目结合Intel QAT硬件加速器，实现并行化的可信启动校验。

## 三、总结
优化可信启动校验时间需要结合具体场景，选择合适的优化方法：

+ 轻量化校验适合嵌入式和物联网设备。
+ 并行化与硬件加速适合高性能服务器。
+ 延迟校验与缓存机制适合桌面操作系统和用户终端。

# 二、Hash计算的优化

## 一、镜像优化层面
1. 减小镜像体积
    + 分析问题：镜像中可能包含了不必要的文件或模块，导致哈希计算的工作量过大。
    + 优化方法：
        1. 剔除非必要文件：
            + 对镜像内容进行精简，移除多余的调试信息、日志文件、临时文件和冗余模块。
            + 通过工具（如du、ncdu）分析镜像中体积最大的文件夹，并清理不必要内容。
        2. 拆分镜像：
            + 将庞大的单一镜像拆分为多个小型模块化镜像（Layered Images）。
            + 例如，Docker镜像使用分层存储技术，可以对不变的基础层（Base Layer）跳过重复测量。
        3. 使用压缩技术：
            + 压缩镜像内容以减少哈希计算的数据量。
            + 常用工具：
                + 使用xz压缩文件（比gzip更高的压缩率）。
                + 使用squashfs生成只读、压缩的文件系统。
    + 实际案例：
        + 对于Docker镜像，可以优化Dockerfile，剔除多余构建步骤和中间产物，使用--squash参数进行镜像压缩。

2. 预处理文件系统
    + 分析问题：传统镜像中，文件排列无序，无法快速识别需要校验的区域。
    + 优化方法：
        1. 文件分组与排序：
            + 将镜像中频繁变动的文件与静态文件分开存储。
            + 使用文件排序工具提前对镜像中的文件按路径或大小排序，以优化读取顺序。
        2. 使用固定分区结构：
            + 将镜像划分为多个独立分区，仅对关键分区进行测量。
            + 例如，将核心系统文件存储在独立分区，并对分区整体进行哈希，而不是逐文件计算。


## 二、哈希计算优化层面
1. 合并哈希（Hash Aggregation）
+ 分析问题：逐个文件计算哈希值会产生大量独立的计算任务。
+ 优化方法：
    1. 一次性整体计算：
        + 将镜像的所有内容流式读取并计算整体哈希值，避免逐文件计算带来的时间开销。
        + 工具示例：sha256sum < large_image_file.img。
    2. 分区合并哈希：
        + 针对分区级别计算哈希值，而不是单个文件。例如，对镜像的某个分区生成单一哈希值。
        + 示例：dd if=/dev/sda1 | sha256sum。

2. 使用更快的哈希算法
+ 分析问题：SHA-256虽然安全性较高，但计算速度可能是瓶颈。
+ 优化方法：
    1. 替换哈希算法：
        + 使用更快速的算法（如BLAKE2b或xxHash）替代传统的SHA算法。
        + BLAKE2b比SHA-256更快，同时具有较高的安全性。
    2. 选择低安全需求的哈希：
        + 在某些场景（如开发调试阶段），可以使用轻量级哈希算法（如MD5、CRC32）。
        + 生产环境可在关键步骤切换回SHA-256。
3. 硬件加速
    + 分析问题：哈希计算完全依赖CPU，未充分利用硬件资源。
    + 优化方法：
        1. CPU指令集优化：
            + 使用支持SHA加速的指令集，如Intel SHA Extensions（现代Intel/AMD处理器支持）。
        2. 专用加速硬件：
            + 利用支持加密加速的硬件设备，如Intel QAT（QuickAssist Technology）。
        3. TPM硬件计算：
            + 将部分哈希计算委托给TPM硬件完成，尤其是TPM 2.0中高效的PCR扩展操作。

## 三、可信启动流程优化层面
1. 增量校验
    + 分析问题：每次启动时重新测量所有文件，导致重复计算。
    + 优化方法：
        1. 增量式镜像校验：
            + 记录上次启动的文件哈希值，在镜像未发生变化时跳过校验。
            + 使用文件系统的时间戳或快照（如btrfs、zfs）快速检测文件变更。
        2. 镜像版本签名：
            + 为整个镜像添加数字签名（例如signify工具），在镜像未更新时直接验证签名。
2. 延迟校验
    + 分析问题：完整的可信启动校验会显著延长启动时间。
    + 优化方法：
        1. 允许系统先完成启动，在后台逐步校验非关键组件。
        2. 在启动完成后对内核模块和文件系统完整性进行验证（例如Linux的IMA/EVM）。
3. 优化可信测量流程
+ 分析问题：多线程测量优化后仍然受到流程中I/O瓶颈的限制。
+ 优化方法：
+ 文件分批测量：
+ 按重要性分批次测量文件，例如先测量系统关键组件，再测量非关键文件。
+ 动态测量策略：
+ 在可信启动阶段仅测量启动所需的核心文件，其余文件在运行时动态测量。
+ 四、综合优化方案
+ 假设当前镜像体积为5GB，总校验时间超过1秒，以下是一个综合优化步骤：

+ 镜像精简：

+ 使用du -sh分析文件大小，将冗余文件剔除，将非核心文件移至外部分区。
+ 使用squashfs压缩镜像，压缩率可达50%-70%。
+ 哈希优化：

+ 替换SHA-256为BLAKE2b（或使用SHA-1作为权衡）。
+ 启用硬件加速，如Intel SHA Extensions。
+ 可信流程调整：

+ 使用延迟校验机制，优先校验内核和Bootloader。
+ 引入镜像签名验证，直接验证签名跳过细粒度哈希计算。
+ 工具链支持：

+ 使用IMA结合EVM验证文件系统完整性。
+ 利用tpm2-tools对敏感文件的哈希值进行批量计算并存储到PCR。


# 参考
[https://kafroc.github.io/2020/05/17/%E6%B5%85%E8%B0%88%E5%8F%AF%E4%BF%A1%E5%90%AF%E5%8A%A8.html](https://kafroc.github.io/2020/05/17/%E6%B5%85%E8%B0%88%E5%8F%AF%E4%BF%A1%E5%90%AF%E5%8A%A8.html)
[优化hash树校验](https://patents.google.com/patent/CN100442277C/zh)

