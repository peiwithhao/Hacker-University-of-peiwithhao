1. calloc不会从tcachebin取
2. fastbin大小堆块即使相邻top chunk也不会立即合并
# decrypt_safe_linking
+ 范围`>2.26`
+ 条件：arbitrary read
函数`tcache_put()`

```c
static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);

  /* Mark this chunk as "in the tcache" so the test in _int_free will
     detect a double free.  */
  e->key = tcache_key;

  e->next = PROTECT_PTR (&e->next, tcache->entries[tc_idx]);
  tcache->entries[tc_idx] = e;
  ++(tcache->counts[tc_idx]);
}

#define PROTECT_PTR(pos, ptr) \
  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))
#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)

static void
tcache_key_initialize (void)
{
  if (__getrandom (&tcache_key, sizeof(tcache_key), GRND_NONBLOCK)
      != sizeof (tcache_key))
    {
      tcache_key = random_bits ();
#if __WORDSIZE == 64
      tcache_key = (tcache_key << 32) | random_bits ();
#endif
    }
}
```
加密操作为：
1. 当前freechunk地址右移12位
2. 然后和tcache之前的首个chunk地址进行异或得到next指针

`cipher = next_ptr ^ (plain >> 12)`



# fastbin_dup
利用fastbin, 可以构造freelist为`a->b->a`

+ 范围`2.35`
+ 条件：Double Free

# fastbin_dup_consolidate

分配0x40 大小的chunk,编号1-8

1. 首先填满`tcache_bin`, 使用1-7
2. 释放8, 进入fastbin

```sh
pwndbg> bins
tcachebins
0x50 [  7]: 0x55555555b890 —▸ 0x55555555b840 —▸ 0x55555555b7f0 —▸ 0x55555555b7a0 —▸ 0x55555555b750 —▸ 0x55555555b700 —▸ 0x55555555b6b0 ◂— 0
fastbins
0x50: 0x55555555b8d0 ◂— 0
unsortedbin
empty
smallbins
empty
largebins
empty
```
3. 此时分配一个0x400大小的堆块，会首先触发`malloc_consolidate`，将fastbin和top chunk合并，然后分配largebin
4. 此时如果触发double free 8, 那么就会导致这个分配的largebin被释放到tcachebin, 大小为0x400

触发`malloc_consolidate`的时机有：
1. `__int_malloc`: 分配一个large size的块
2. `_int_malloc`: 没有为当前chunk找到的bins,并且top chunk很小
3. `_int_free`: 如果chunk_size > FASTBIN_CONSOLIDATION_THRESHOLD (65536)
4. mtrim: Always 
5. `_libc_mallopt`: Always


# fastbin_dup_into_stack
+ 范围`2.35`
+ 条件：Double Free
实际上类似于`fastbin_dup`, 然后修改fd指针到栈上构造的chunk头部，这里需要注意进行safelink构造


# fastbin_reverse_into_tcache
+ 范围`2.35`
+ 条件: UAF

利用方式：
1. 填满tcachebins , t7->t6->...t2->t1
2. 填满fastbins, f7->f6->...f2->f1
3. 修改f1的fd指针, 导致f7->f6->...f2->f1->fake
4. 申请堆块,排空tcachebins
5. 继续申请堆块，会导致从fastbins中申请，也就是拿到f7
6. 但此后fastbin的内容会填充到tcachebin, 变成fake->f1->f2->...->f6
7. 这里没检查fake的fd指针是因为fastbin个数为7个已经满了，如果不满的话会检查fd指针，如果是非规范值或者空则会崩溃


# large_bin_attack
+ 范围`2.35`
+ 条件: 任意写，可以将任意地址写入一个chunk地址


在2.30之后存在两个新的检查
子链检查
```c
if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\n");
    malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n");
```
主链检查
```c
if (bck->fd != fwd)\n");
    malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n\n");
```


利用方式：
1. 分配0x428大小堆块p1， 分配0x18小堆块(防止合并)
2. 分配0x418大小堆块p2(要注意这里分配的p2需要与p1在同一largebin内)， 分配0x18小堆块(防止合并)
3. 释放p1, 放入unsortedbin, 此时分配0x438, 触发堆块调整，p1放入largebin
4. 释放p2, 此时p2放入unsortedbin
5. 修改p1->bk_nextsize为target-0x20
6. 分配0x438,触发p2放入largebin,变成p1->p2->target(glibc不检查bk_nextsize)
7. p1->bk_nextsize->fd_nextsize(也就是target) 将被修改为p2

利用代码

```c

    // so we can exploit under easier condition in the else branch
      if (fwd != bck)
        {
          /* Or with inuse bit to speed comparisons */
          size |= PREV_INUSE;
          /* if smaller than smallest, bypass loop below */
          assert (chunk_main_arena (bck->bk));
          if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
            {
              fwd = bck;
              bck = bck->bk;
				
              victim->fd_nextsize = fwd->fd;
              victim->bk_nextsize = fwd->fd->bk_nextsize;
              fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
            }
          else
....
```
在释放堆块到largebin的途中，如果释放堆块是最小的则会走上面的路径
![./img/largebin_attack_2_binlist.png](./img/largebin_attack_2_binlist.png)

largebin attack 博客[https://4xura.com/binex/large-bin-attack/](https://4xura.com/binex/large-bin-attack/)


# house of botcake
范围: 2.35
条件: double free

利用方式:
1. 分配9个堆块堆块, 再分配一个小堆块防止和top chunk合并
2. 释放前7个堆块到tcachebin
3. 释放堆块9到unsortedbin
4. 释放堆块8触发合并
5. 分配同样大小的堆块，将从tcachebin中获取
6. 此时触发double free 堆块9, 会将堆块9再放入tcachebin, 这样会造成之前合并的[8, 9]堆块中存在overlapp
7. 分配unsortedbin的大堆块，修改堆块9的fd指针


# house of spirit

范围: 2.35
条件: 知道目标地址，能够写入目标地址

利用方式：
1. 分配7个堆块然后释放来填充tcache_bin
2. 伪造假堆块,可以是栈上，然后释放,需要注意lsb位,这将导致假堆块进入fastbin
3. 使用calloc就可以分配假堆块了

# house of einherjar
范围:2.35
条件: off by one, 需要堆空间泄漏

利用方式:
1. 分配a堆块，例如这里是0x38分配大小，然后在a堆块里面伪造信息
```text
0x55555555b290	0x0000000000000000	0x0000000000000041	........A.......
0x55555555b2a0	0x0000000000000000	0x0000000000000060	........`.......
0x55555555b2b0	0x000055555555b2a0	0x000055555555b2a0	..UUUU....UUUU..
0x55555555b2c0	0x0000000000000000	0x0000000000000000	................
```
2. 然后分配b堆块，大小设置为0x28,刚好造成overlap
3. 分配c堆块，大小为0xf8
4. 触发off by one, 将b堆块溢出写`\x00`, 此时c堆块的`size|prev_inuse`从0x101变为0x100
5. 修改b的最后8字节来伪造虚假上一个堆块大小, 例子为0x60
6. 填满tcachebins,使用被溢出的堆块大小需要一致,然后释放堆块c,此时将触发consolidate,将导致合并伪造堆块
```text
x55555555b290	0x0000000000000000	0x0000000000000041	........A.......
0x55555555b2a0	0x0000000000000000	0x0000000000000161	........a.......
0x55555555b2b0	0x000000055555555b	0x0000000000000000	[UUU............
0x55555555b2c0	0x0000000000000000	0x0000000000000000	................
```
7. 分配0x158大小堆块
8. 分配b堆块大小0x28的堆块d然后释放，将会置入tcachebin
9. 释放b堆块，那么b堆块将会放置入tcachebin,形成 b->d
10. 然后通过overlap修改b堆块指针,造成tcache poisoning

# house of lore
范围: 2.35
条件: 

利用方式:
1. 分配small chunk s0,分配大小0x100
2. 分配剩余7个chunk, 大小为0x100, 用来填满tcache, t0-t6
3. 分配大块来防止合并到topchunk
4. 释放t0-t6填满tcachebin, 然后释放s0到unsortedbin
5. 分配大块来让s0被放入smallbin
6. 利用UAF来修改s0的bk指针指向伪造堆块,然后排空tcachebin
7. 分配堆块来获取s0, 这将导致伪造堆块分配到tcachehbin


# mmap_overlapping_chunks

范围:2.35
条件: 修改堆块size位

利用方式:
1. 分配3个巨大堆块0x100000大小， 内存分布如下 ```text
Current System Memory Layout 
```
================================================
running program
heap
....
third mmap chunk
second mmap chunk
LibC
....
ld
first mmap chunk
===============================================
```
2. 修改chunk3的size,修改为恰好覆盖chunk2, 然后free掉chunk3
3. 这将导致mmap区域被释放
4. 分配一个比刚刚释放区域还大的堆块finalchunk，例如0x300000, 将会覆盖刚刚释放的mmap区域
5. 此时将导致向finalchunk可以写入chunk2的内容


# tcache_poisoning
范围：2.35
条件：堆地址泄漏

利用方式：
修改tcachebin链条中的fd指针

# tcache_house_of_spirit
范围：2.35
条件：堆地址泄漏

利用方式：
1. 伪造堆块，然后释放
2. 下次分配可以从tcache分配

# tcache_metadata_poisoning
范围: 2.35
条件: 任意写, 堆地址泄漏

利用方式:
1. 修改tcache tcache metadata

# tcache_stashing_unlink_attack
范围：2.27，2.29，2.31，2.35
条件：能够写victim->bk, 至少使用一次calloc，需要一个可写地址来绕过glibc 检查

利用方式:
1. 分配9个堆块chunk0-chunk8,大小为0x90,然后释放堆块chunk3-chunk8, 然后释放chunk1, tcachebin被填满 t1->t8->t7->...->t3
2. 然后释放chunk0, chunk2, 这将释放回unsortedbin, 变为u2->u0
3. 分配大于当前堆块的内容比如0xa0, 由于unsortedbin找不到同等大小，那么会触发合并，将unsortedbin放入smallbin，变成 s2->s0
4. 然后分配两个额外0x90对象，清理一下tcache的空间，现在变成t7->t6->t5->t4->t3, 然后smallbin有两个堆块s2->s0
5. 修改s2的bk指针指向fakechunk, 下面使用calloc从smallbin里面申请空间，会首先将s2分配给用户，然后将剩余的堆块置入tcacehbin
6. 之后分配tcachebin





