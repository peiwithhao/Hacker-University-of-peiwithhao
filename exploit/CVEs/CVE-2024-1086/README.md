# CVE-2024-1086
该漏洞是一个netfilter中处理HOOK函数时导致的Double Free 释放漏洞
# 环境配置
linux kernel: linux-6.3.4

```config
CONFIG_NF_TABLES=y
CONFIG_NF_TABLES_INET=y
```


# 基础知识
构造IP包发送，需要用到两种系统调用,分别是`socket, sendto`
socket系统调用用来构建套接字socket, 套接字用来收发数据，并且与内核sock进行关联
sendto则利用socket传回的fd来发送信息
```c

...
    sendto_ipv4_ip_sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
...
```
这里的`SOCK_RAW`表示我们自己构造IP头部

用户使用`sendto`向指定地址发送消息的时候，会首先调用内核系统调用`__x64_sys_sendto`
在本次漏洞利用中我们是构造了`RAW_INET`包,该flag表示我们是想要由自身来提供头部信息
这里大致介绍一下在`sendto`系统调用的流程中，执行流在内核中的旅行路线,这里将主要聚焦于netfilter hook点


1. 首先调用`__sys_sendto -> sock_sendmsg -> sock_sendmsg_nosec -> inet_sendmsg`
2. `inet_sendmsg`根据socket来执行间接调用函数，这里经过调试发现是`raw_sendmsg()`(这里ops的初始化是在socket的创建过程中，其中依然涉及大量间接调用的赋值)
3. `raw_sendmsg()`是发送网络数据包的核心代码，这里调用`raw_sendhd_rinc()`,该函数在最后涉及到`NF_INET_LOACL_OUT`，这是这个流程遇到的第一个hook点
4. 在上面遇到的第一个hook点中,传递参数定义了回调函数`dst_output()`,而`dst_output()->ip_output()`
5. `ip_output()`函数主体最后会调用`NF_INET_POST_ROUTING`,之后是调用回调函数`ip_finish_output()`来清除skb
6. 此时如果你发送的目的地址环回地址，则会触发软中断，软中断调用`__netif_receive_skb_one_core`来触发，经过一系列调用链条最终调用`ip_rcv()`
7. `ip_rcv()`首先调用`ip_rcv_core()`处理接收到的skb,然后触发`NF_INET_PRE_ROUTING`hook, 在一些相应的hook函数完毕后调用回调函数`ip_rcv_finish()`
8. `ip_rcv_finish()`调用函数`ip_rcv_finish_core()`函数，主要判断目的地址的规范性一类然后来判断是否需要丢弃
9. 如果不需要丢弃，则调用`dst_input()`
10. `dst_input()`首先判断该ip包是否是分片包，如果是则调用`ip_defrag()`,否则触发钩子`NF_INET_LOCAL_IN`
11. `ip_defrag()`该函数用来处理分片包,该函数会调用`ip_find()`来查找是否已经有同一个IP包的分片组成的队列，如果有则返回队列，否则创建新的队列
12. `ip_defrag()`继续调用`ip_frag_queue()`来真正处理该分片的信息
13. `ip_frag_queue()`来查看该ip头部的字段长度是否安全，如果出现错误则会直接丢弃该skb并且释放整个队列
14. `ip_frag_queue()`会检查几个条件来判断是否ip包是否全部分片均到达，如果到达则调用`ip_frag_reasm()`来重组新的skb,然后将skb重新注入到网络协议栈的接收路径
15. 之后通过返回0，返回到`ip_local_deliver()`然后触发钩子`NF_INET_LOCAL_IN`,之后继续调用回调函数

所以，如果我们发送一个数据包分片的时候，经过的netfilter hook点顺序可能是
`NF_INET_LOCAL_OUT -> NF_INET_POST_ROUTING -> NF_INET_PRE_ROUTING -> NF_INET_LOCAL_IN`


# 漏洞原因

漏洞出自于`nf_hook_slow()`

```c
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
		 const struct nf_hook_entries *e, unsigned int s)
{
	unsigned int verdict;
	int ret;

	for (; s < e->num_hook_entries; s++) {
		verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
		switch (verdict & NF_VERDICT_MASK) {
		case NF_ACCEPT:
			break;
		case NF_DROP:
			kfree_skb_reason(skb,
					 SKB_DROP_REASON_NETFILTER_DROP);
			ret = NF_DROP_GETERR(verdict);
			if (ret == 0)
				ret = -EPERM;
			return ret;
		case NF_QUEUE:
			ret = nf_queue(skb, state, s, verdict);
			if (ret == 1)
				continue;
			return ret;
		default:
			/* Implicit handling for NF_STOLEN, as well as any other
			 * non conventional verdicts.
			 */ return 0;
		}
	}

	return 1;
}
EXPORT_SYMBOL(nf_hook_slow);
```

在switch case 语句中`NF_DROP`的选项,这是由于当用户所设计的netfilter hook函数最后返回`NF_DROP`时即将执行的程序流程

这里的流程将会首先释放这个skb，但是这里程序再次判断了`NF_DROP_GETERR`来获取返回参数，
这就给了用户一定的操作空间，如果可以通过这个函数将ret修改为NF_ACCEPT, 也就是1, 
那么当这个函数返回后将回到下面的`nf_hook()`函数

`nf_hook()`函数返回1则会导致调用后续的`okfn()`,这里使用`ip_forward()`进行举例
该函数将在最后调用`NF_HOOK()`函数

```c

...
	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,
		       net, NULL, skb, skb->dev, rt->dst.dev,
		       ip_forward_finish);
...
```

而`NF_HOOK()`函数将会根据`nf_hook()`函数的返回值来决定是否调用`okfn`参数指针所指向的地址
返回值为1则说明hook函数处理的返回值为`NF_ACCEPT`

```c
static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
	struct net_device *in, struct net_device *out,
	int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
	int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
	if (ret == 1)
		ret = okfn(net, sk, skb);
	return ret;
}
```


那么就能在之后对skb进行二次释放,因此导致了double free

# 触发方式
知道了漏洞出处，接下来的步骤便是尝试触发，在`nf_hook_slow()`函数当中
```c

int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
		 const struct nf_hook_entries *e, unsigned int s)
{
    ...
	for (; s < e->num_hook_entries; s++) {
		verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
		switch (verdict & NF_VERDICT_MASK) {
		case NF_ACCEPT:
			break;
		case NF_DROP:
			kfree_skb_reason(skb,
					 SKB_DROP_REASON_NETFILTER_DROP);
			ret = NF_DROP_GETERR(verdict);
    ...

```


这里的for循环是调用当前hook点里面所有的hook,并且返回值是可以由用户构造的
所以为了满足我们的目的，需要verdict满足:

```c

static inline int NF_DROP_GETERR(int verdict)
{
	return -(verdict >> NF_VERDICT_QBITS);
}

#define NF_DROP 0                  
#define NF_ACCEPT 1
#define NF_VERDICT_MASK 0x000000ff 
#define NF_VERDICT_QBITS 16
```



    1. verdict & NF_VERDICT_MASK == NF_DROP;
    2. NF_DROP_GETERR(verdict) == NF_ACCEPT;

因此计算得出可以构造`verdict = 0xffff0000`即可满足这样一个条件


# 相关技巧
## Page Double Free
从`__free_pages()`函数可以看出

```c

void __free_pages(struct page *page, unsigned int order)
{
	/* get PageHead before we drop reference */
	int head = PageHead(page);

	if (put_page_testzero(page))
		free_the_page(page, order);
	else if (!head)
		while (order-- > 0)
			free_the_page(page + (1 << order), order);
}
EXPORT_SYMBOL(__free_pages);
```

当使用`put_page_testzero()`发现页面的引用计数为1,则将释放他
而如果此时我们不做任何事直接将他应用在double free上，则`put_page_testzero()`将会发现`page.refcount == 0`从而报错
```c
static inline int put_page_testzero(struct page *page)
{
	VM_BUG_ON_PAGE(page_ref_count(page) == 0, page);
	return page_ref_dec_and_test(page);
}
```

因此可以在double free中途插入重分配，使得refcount++,这样就可以绕过这部分检查
作者的例子如下:
```c
static void kref_juggling(void)
{
    struct page *skb1, *pmd, *pud;

    skb1 = alloc_page(GFP_KERNEL);  // refcount 0 -> 1
    __free_page(skb1);  // refcount 1 -> 0
    pmd = alloc_page(GFP_KERNEL);  // refcount 0 -> 1
    __free_page(skb1);  // refcount 1 -> 0
    pud = alloc_page(GFP_KERNEL);  // refcount 0 -> 1

    pr_err("[*] skb1: %px (phys: %016llx), pmd: %px (phys: %016llx), pud: %px (phys: %016llx)\n", skb1, page_to_phys(skb1), pmd, page_to_phys(pmd), pud, page_to_phys(pud));
}
```

## Order 4 -> Order 0

在`__do_kmalloc_node()`函数当中，

```c

#define KMALLOC_MAX_CACHE_SIZE	(1UL << KMALLOC_SHIFT_HIGH)
#define KMALLOC_SHIFT_HIGH	(PAGE_SHIFT + 1)
#define PAGE_SHIFT		12

static __always_inline
void *__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)
{
    ...
	if (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {
		ret = __kmalloc_large_node(size, flags, node);
        ...
	ret = __kmem_cache_alloc_node(s, flags, node, size, caller);
    ...
}
```
在使用`kmalloc`分配内存堆块的过程中，
如果分配size大小大于`KMALLOC_MAX_CACHE_SIZE`                    ◄─
那么将会使用`alloc_page()`直接从伙伴系统申请页面

但某些对象即使小于`KMALLOC_MAX_CACHE_SIZE`,同样会由于开发人员减少开销的操作来直接使用`alloc_page()`,
例如PTE page

当对象使用`alloc_pages()`分配或者释放的时候，如果大小小于`order 3`,则会从PCP list里面进行分配或者释放
也就是说当内核申请页表空间的时候首先将会使用`alloc_pages()`在当前CPU的pcp list里面分配页面

目前目标:
1. 分配指定大小skb,
2. 准备双重释放该skb，
3. 第一次释放skb,延迟第二次释放skb
4. 分配页表, 占领该skb
5. 第二次释放skb,此时页表也被释放
6. 重新申请该页

目前可以获取的情报:
1. 分配的skb能够被页表所占领
2. 页表由`alloc_pages()`分配，从pcp list得到
3. skb如果小于8K,则将从slab allocator分配
4. skb如果大于8K且小于8x4K,则从page allocator分配或者释放，但是是从pcp list进行分配
5. 如果skb 大于 8x4k, 同样从page allocator分配,直接从buddysystem获取
6. 如果skb采用3分配和释放，则skb释放后只会回到slab当中，无法造成skb和PTE page占用同一页
7. 如果skb采用4分配和释放，则skb虽然是从pcp list, 但是pcp list里面也有order差异，也无法造成共同占用
8. skb采用5,则skb将会释放回buddysystem当中，此时有可能造成共同占用，当pcp list没有符合的页面就将从buddysystem获取

综上，skb将会以 order-4(16x4KB)的形态出击

而为了造成pcp list没有符合的页面，需要首先耗尽其中所有的页
内核函数`rmqueue_bulk()`由`__rmqueue_pcplist()`分配，当pcplist为空的时候，就将使用该函数来填充`rmqueue_bulk`,
该函数将从buddysystem获取页面来填充pcplist

因此这里可以堆喷`PTE page`来消耗该pcplist

## IP fragment trick
使用了IP包分片的技巧来巧妙的进行延迟的double free
IP分片这一块是408网络的重点部分:), 如果记得不太详细可以直接查看该[博客](https://packetpushers.net/blog/ip-fragmentation-in-detail/)
在上面基础知识我们知道如果传递IP分片到目标机器，首先并不会直接送入上层进行分析，而是在内核维持一个skb队列，
等待队列满了之后再递交上层处理

我们知道在上面的漏洞点中，我们可以在处理netfilter hook函数的时候将某个skb进行一次释放，而释放过后依旧会走完全程，
在通过漏洞释放完skb之后，`skb->len`字段将会被随机数覆盖，这是内核的保护机制,此时二次释放该skb可能会导致内核panic
因此何时触发二次释放就十分重要，
这里存在两个技巧：
1. 分片包在内核维持的队列有时间限制，一旦超过了这个时间限制，则该队列的skb包则会全部释放，
这个时间限制由内核的sysfs文件系统掌控,位于`/proc/sys/net/ipv4/ipfrag_time`,而设置他并不需要root权限，
因此我们如果将该值调大，那完全可以创建一个无限大的窗口供我们使用
2. 仔细阅读`ip_frag_queue`的代码，当他检查该分片头部的时候如果`offset==len`,那么将会判断是错误包，直接释放该skb队列,并且不会检测之前放入queue的头部是否正确

整合该两点，我们就可以通过构造IP头，在任意我们想要的时机对一个skb进行double free


                  set ipfrag_time=9999   │
                            │            │
                            │            │
                            │            │
                            ▼            │
                 sendto ip fragment skb1 │
                            │            │ ─┐
          freed by exploit  ▼            │  │
                            │            ▼  │
                   waiting in queue      │  │ i can do everthing i want
                            │            │  ▼
                            │            │  │
                            ▼            │  │
                            │            │ ─┘
                            │            │     sendto ip fragment skb2 
                            └──────────┬─┴───── but offset == len
                                       │
                                       ▼
                            free skb1 skb2 in current cpu
                        (double free)



## 堆喷PTE
需要堆喷PTE,在dirtypagetable里面就已经讲解到,可以通过用户使用mmap来分配页表,
但是mmap的时候并不是分配页表的时候，他会首先在内核task_struct中建立VMA,当用户访问VMA区域内的地址的时候才会出发page fault,
然后造成页表分配

但是如果选择的映射区域不准确，则可能会造成一系列分配例如PUD,PMD的额外分配,这样在我们堆喷的过程中就可能造成噪音从而导致利用失败

那么我们就可以选择舍弃一部分PTE,那就是首先通过分配某个PTE的第一个page来提前将PMD和PUD分配完毕,例子如下


                                    PUD              PMD             PTE           page
                            ┌────►┌────────┐  ┌──►┌─────────┐ ┌──►┌─────────┐   ┌─────────┐
                  PGD       │     │        ├──┘   │         ├─┘   │         ├──►│ aaaaaaa │
               ┌───────┐    │     ├────────┤      ├─────────┤     ├─────────┤   │         │
               │       ├────┘     │        │      │         │     │         │   │         │
               ├───────┤          │        │      │         │     │         │   │         │
               │       │          │        │      │         │     │         │   │         │
               │       │          └────────┘      └─────────┘     └─────────┘   └─────────┘
               └───────┘


对于提前的VMA写入就将导致PUD和PMD的分配，接下来当继续访问在PUD/PMD可表示的虚拟地址范围内的地址就可以保证稳定分配PTE



## Dirty pageDirectory


作者由dirtypagetable启发而来,简单介绍一下dirty pagetable的原理在于:
> [!NOTE]
> 当存在UAF的时候,将漏洞堆块和PTE页表分配到一起，然后就可以通过操作漏洞堆块来影响PTE页表，从而导致任意物理地址写
> 但是这个步骤需要漏洞堆块稳定能操作，比如说是稳定写入字节

                    step1 ────free the obj─► step2 ──mmap──────► step3
                 ┌───────────┐        ┌─────────────┐     ┌───────────┐
                 │vuln object│        │             │     │   PTE     │
                 └───────────┘        └─────────────┘     └───────────┘
                                                                ▲
                                                                │
                                                 ACCESS PTE BY VULN OBJECT




但可惜的是有时候无法获取一个稳定的漏洞利用模块，比如这次漏洞的skb，因此作者仅仅使用一次漏洞触发，
之后的操作完全是对于用户虚拟地址的访问来达成任意物理地址读写
实际操作起来的原理十分的简单，仅仅是使PMD和PTE均分配到同一个物理页面，这样做导致的后果就是:

> [!IMPORTANT]
> 原来PTE访问的page页面会变成PMD访问到的PTE页面，所以如果能够在原来PTE访问的page页面伪造合适的页表项,则就可以通过PMD来执行任意物理地址读写操作



               ┌───► PUD0 ────► PMD0 ───────► PTE0 ──────►  page0 ───► ???
               │                               │             │          │
               │                               │             │          │
               │                               │             │          │
         PGD ──┤                  ┌─same phys──┘ ┌─same phys─┘     ┌─?──┘
               │                  │              │                 │
               │                  │              │                 │
               └───► PUD1 ────► PMD1(PTE0)───► PTE1(page0) ───► page1(???)


## TLB 刷新
[TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)用来缓存虚拟地址到物理地址的映射，从而可以使得加快页表访存,
所以在dirty pagedirectory的工作下我们需要清空TLB来保证该技术的稳定性,而这一步骤也可以被称为刷新TLB

这里该作者提出的刷新方法是在堆喷PMD和PTE的时候，可以将他们标记为共享页面，然后通过创建子进程，然后该子进程调用`munmap()`刷新内存
最后让子进程进入睡眠



# 漏洞利用流程
接下来讲解具体流程:

1. 创建用户和网络命名空间，在其中可以让我们执行特权操作
2. 做环境准备，例如绑定cpu核等
3. 启动环回网卡,然后禁用rpf(反向路径转发),因为后续需要使用特制ip头
4. 构造netfilter hook, 这里hook点为`NF_INET_PRE_ROUTING`,具体原因可以参考基础知识环节
5. 分配大量udp skb, 仅仅用来放在double free之间来防止错误
6. 分配skb1, 该skb1出发netfilter hook漏洞,进行释放,由于是分配0x8000, 所以从order-4的buddysystem分配和释放，但是此时还在分片队列里面
7. 释放大量udp skb
8. 此时分配大量PTE页，此时从order-0分配，首先耗尽pcp-list,然后pcp-list补充页面则从buddysystem,只需要数量足够大，就会导致分配到的PTE页面的堆块和skb数据块重叠
9. 发送损坏的skb2,触发skb queue释放，从而导致刚刚分配到的PTE页面释放
10. 此时分配pmd页面,这里大家可能会担心，一个order-4的页面的释放到buddy system, 为什么一个order-0的getpages请求能获取到,这是因为实际上此时被double free 释放的PTE所在的page已经被修改为order0了,而在释放skb的时候并不会检查该page的字段，按照常规的`kfree->free_large_kmalloc`之时检测到的只会是order-0页面的freepage，该pmd页面将会和刚刚的pte页面共享同一个物理页




# 页表标识
```text

~ PT Entry ~                                                    Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
┌─── NX                                                    Dirty ──────┐|| ||||
|┌───┬─ Memory Protection Key              Page Attribute Table ──────┐||| ||||
||   |┌──────┬─── Ignored                               Global ─────┐ |||| ||||
||   ||      | ┌─── Reserved                          Ignored ───┬─┐| |||| ||||
||   ||      | |┌──────────────────────────────────────────────┐ | || |||| ||||
||   ||      | ||            4KB Page Physical Address         | | || |||| ||||
||   ||      | ||                                              | | || |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX
       56        48        40        32        24        16         8         0
```




# 引用
[https://pwning.tech/nftables/](https://pwning.tech/nftables/)
[https://bsauce.github.io/2024/05/10/CVE-2024-1086/#2-3-ip%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87](https://bsauce.github.io/2024/05/10/CVE-2024-1086/#2-3-ip%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87)
[https://packetpushers.net/blog/ip-fragmentation-in-detail/](https://packetpushers.net/blog/ip-fragmentation-in-detail/)
[https://en.wikipedia.org/wiki/Translation_lookaside_buffer](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)
