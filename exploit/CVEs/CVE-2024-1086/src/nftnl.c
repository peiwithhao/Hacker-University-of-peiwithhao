#define _GNU_SOURCE
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>

#include <netinet/ip.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include "nftnl.h"
#include "libnftnl/expr.h"
#include "libnftnl/table.h"
#include "libnftnl/chain.h"
#include "libnftnl/rule.h"
#include "libmnl/libmnl.h"
#include "libnftnl/common.h"


static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t dreg,
			uint32_t offset, uint32_t len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("payload");
	if (e == NULL) {
		perror("expr payload oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);

	nftnl_rule_add_expr(r, e);
}

static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op,
		    const void *data, uint32_t data_len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("cmp");
	if (e == NULL) {
		perror("expr cmp oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op);
	nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}


static void add_set_verdict(struct nftnl_rule *r, uint32_t val){
    struct nftnl_expr *e;
    e = nftnl_expr_alloc("immediate");
	if (e == NULL) {
		perror("expr cmp");
		exit(EXIT_FAILURE);
	}
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, val);
    nftnl_rule_add_expr(r, e);
}



static struct nftnl_table *alloc_table(uint16_t family, const char *table_name){
    
    struct nftnl_table *t;

    t = nftnl_table_alloc();
    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name);
    return t;
}


static struct nftnl_chain *alloc_chain(uint8_t family, int hooknum, int prio, const char *table_name, const char *chain_name){
    
    struct nftnl_chain *c;

    c = nftnl_chain_alloc();
	nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_HOOKNUM, hooknum);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_PRIO, prio);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_FAMILY, family);
    return c;
}

static struct nftnl_rule *alloc_rule(uint8_t family, const char *table_name, const char *chain_name, unsigned char proto){
    struct nftnl_rule *r;
    r = nftnl_rule_alloc();

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    // judge proto while it is proto
    add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1, offsetof(struct iphdr, protocol), sizeof(unsigned char));
    add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &proto, sizeof(unsigned char));

    // first 4 bytes has to be \x41
    add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1, (uint32_t)sizeof(struct iphdr), (uint32_t)4);
    add_cmp(r, NFT_REG_1, NFT_CMP_EQ, "\x41\x41\x41\x41", 4);
    add_set_verdict(r, (uint32_t)0xffff0000);

    return r;
}


void configure_nftables(void){
    struct mnl_socket *nl_socket; 
    struct mnl_nlmsg_batch *batch;
    struct nlmsghdr *nlh;
    uint32_t portid, seq = time(NULL);
    int batching;
    ssize_t ret;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nftnl_table *t;
    struct nftnl_chain *c;
    struct nftnl_rule *r;

    t = alloc_table(NFPROTO_INET, "filter_table");
    c = alloc_chain(NFPROTO_INET, NF_INET_PRE_ROUTING, 10, "filter_table", "filter_chain");
    r = alloc_rule(NFPROTO_INET, "filter_table", "filter_chain", 70);

    //open socket which communicated to netfilter
    //Actually just socket(AF_NETLINK, SOCK_RAW, bus);
    nl_socket = mnl_socket_open(NETLINK_NETFILTER);
	if (nl_socket == NULL) {
		perror("mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl_socket, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
    //get netlink portid
	portid = mnl_socket_get_portid(nl_socket);

    batching = nftnl_batch_is_supported();
    if(batching < 0){
        printf("[!]Cannot comm with nfnetlink");
        exit(EXIT_FAILURE);
    }

    seq = time(NULL);
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    if(batching){
        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);
    }

	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWTABLE, 
                    nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY),
				    NLM_F_CREATE | NLM_F_ACK | NLM_F_APPEND, seq++);

	nftnl_table_nlmsg_build_payload(nlh, t);
    nftnl_table_free(t);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWCHAIN, 
                                     nftnl_chain_get_u32(c, NFTNL_CHAIN_FAMILY),
                                    NLM_F_CREATE | NLM_F_ACK | NLM_F_APPEND, seq++);

    nftnl_chain_nlmsg_build_payload(nlh, c);
    nftnl_chain_free(c);
    mnl_nlmsg_batch_next(batch);


    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWRULE, 
                                     nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
                                    NLM_F_CREATE | NLM_F_ACK | NLM_F_APPEND, seq++);

    nftnl_rule_nlmsg_build_payload(nlh, r);
    nftnl_rule_free(r);
    mnl_nlmsg_batch_next(batch);


    if(batching){
        nftnl_batch_end(mnl_nlmsg_batch_current(batch),seq++);
        mnl_nlmsg_batch_next(batch);
    }
    printf("[+]Sending nftables tables/chains/rules by netlink...\n");
    ret = mnl_socket_sendto(nl_socket, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
    if(ret < 0){
        perror("mnl_socket_sendto");
        exit(EXIT_FAILURE);
    }

    mnl_nlmsg_batch_stop(batch);

    ret = mnl_socket_recvfrom(nl_socket, buf, sizeof(buf));
    if(ret < 0){
        perror("mnl_socket_recvfrom");
        exit(EXIT_FAILURE);
    }
    ret = mnl_cb_run(buf, ret, 0, portid, NULL, NULL);
    if(ret < 0){
        perror("mnl_cb_run");
        exit(EXIT_FAILURE);
    }
    mnl_socket_close(nl_socket);
}
