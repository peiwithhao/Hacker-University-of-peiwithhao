//gcc ./bpf.c -o bpf
#include <stdio.h>
#include <stdint.h>    //为了uint64_t等标准类型的定义
#include <linux/bpf.h>    //位于/usr/include/linux/bpf.h, 包含BPF系统调用的一些常量, 以及一些结构体的定义
#include <sys/socket.h>
#include <sys/syscall.h>    //为了syscall()
#include <sys/syscall.h>
#include <unistd.h>

int prog_fd = -1;
int socks[2] = {0};
//类型转换, 减少warning, 也可以不要
#define ptr_to_u64(x) ((uint64_t)x)

//对于系统调用的包装, __NR_bpf就是bpf对应的系统调用号, 一切BPF相关操作都通过这个系统调用与内核交互
int bpf(int cmd, union bpf_attr *attr) {
    return syscall(__NR_bpf, cmd, attr, sizeof(*attr));
}

int create_map(union bpf_attr* attrs){
    int result = -1;
    result = bpf(BPF_MAP_CREATE, attrs);
    return result;
}

int update_map_element(int map_fd, uint64_t key, void *value, uint64_t flags){
    int result = -1;
    union bpf_attr attr = {
        .map_fd = map_fd,
        .key    = (uint64_t)&key,
        .value  = (uint64_t)value,
        .flags  = flags
    };
    result = bpf(BPF_MAP_UPDATE_ELEM, &attr);
    return result;
}

int lookup_map_element(int map_fd, uint64_t key, void *value){
    int result = -1;
    
    union bpf_attr attr = {
        .map_fd = map_fd,
        .key    = (uint64_t)&key,
        .value  = (uint64_t)value,
    };
    result = bpf(BPF_MAP_LOOKUP_ELEM, &attr);
    return result;
}

int obj_get_info_by_fd(union bpf_attr* attrs){
    int ret = -1;
    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);
    return ret;
}


//通过系统调用, 向内核加载一段BPF指令
int bpf_prog_load(struct bpf_insn* insns, uint32_t insn_cnt)
{
    int ret = -1;
    char verifier_log_buff[0x200000] = {0};
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,        //程序类型
        .insns     = ptr_to_u64(insns),    //指向指令数组的指针
        .insn_cnt  = insn_cnt,    //有多少条指令
        .license   = ptr_to_u64(""),    //指向整数字符串的指针
        .log_buf   = ptr_to_u64(verifier_log_buff),    //log输出缓冲区
        .log_size  = sizeof(verifier_log_buff),    //log缓冲区大小
        .log_level = 2,    //log等级
    };
    if(prog_fd <= 0){
        printf("[+]bpf syscall...\n");
        prog_fd = bpf(BPF_PROG_LOAD, &attr);
    }
    if(prog_fd < 0){
        perror("bpf");
        puts(verifier_log_buff);
        return ret;
    }
    
    /* 创建套接字数组 */
    if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks) != 0){
        return ret;
    }
    ret = 0;
    return ret;
}

int attach_bpf_prog(void){
    int ret = -1;
    if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(int))){
        printf("wtf\n");
        return ret;
    }
    ret = 0;
    return ret;
}

int bpf_prog_run(void){
    int ret = -1;
    if(0xa != write(socks[1], "peiwithhao", 0xa)){
        return ret;
    }
    return 0;
}

