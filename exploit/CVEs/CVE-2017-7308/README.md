<!--toc:start-->
- [CVE 2017 7308](#cve-2017-7308)
- [实验环境](#实验环境)
- [AF_PACKET 套接字](#afpacket-套接字)
- [ring buffer](#ring-buffer)
- [AF_PACKET 套接字具体实现](#afpacket-套接字具体实现)
- [环形缓冲区的设置](#环形缓冲区的设置)
<!--toc:end-->

# CVE 2017 7308

# 实验环境
+ 主机发行版:ubuntu 16.04LTS
+ kernel: linux-4.10.6
+ config: `CONFIG_PACKET=y`, `CONFIG_USER_NS`, `CONFIG_SLAB=y`, `COFNIG_E1000, CONFIG_E1000E=y`

# AF_PACKET 套接字
这个套接字用来在设备驱动层发送或者接受数据包,这使得用户可以自定义物理层协议
如果要创建这种套接字需要我们在用户命名空间具有`CAP_NET_RAW`权限

我们可以使用`tcpdump`这个工具在某个接口上接受所有的数据包

而进程用来收发数据包则是使用了一个内核创建的缓冲区，然后用户使用mmap来映射到这个缓冲区来进行读写数据

# ring buffer

用户要创建环形缓冲区需要使用结构体`struct tpacket_req3`,用户需要利用这个结构体向setsocketopt系统调用传递信息
而每个数据包会存放在一个单独的帧当中,在`TPACKET_V3`环形缓冲区当中,
帧的大小是变化的


```c
struct tpacket_req3 {
	unsigned int	tp_block_size;	/* Minimal size of contiguous block */	// 每个内存块的大小
	unsigned int	tp_block_nr;	/* Number of blocks */					// 内存块的个数
	unsigned int	tp_frame_size;	/* Size of frame */						// 每个帧的大小，TPACKET_V3会忽视这个字段
	unsigned int	tp_frame_nr;	/* Total number of frames */			// 帧的个数，TPACKET_V3会忽视这个字段
	unsigned int	tp_retire_blk_tov; /* timeout in msecs */				// 超时时间（毫秒），超时后即使内存块没有被数据完全填满也会被内核停用（参考下文）,以便用户能尽快读取数据
	unsigned int	tp_sizeof_priv; /* offset to private data area */		// 每个内存块中私有区域的大小。用户可以使用这个区域存放与每个内存块有关的任何信息；
	unsigned int	tp_feature_req_word;									// 一组标志（目前实际上只有一个标志），可以用来启动某些附加功能。
};
```

而多个帧会被分组为内存块block

        ┌────────────────────────────────────────────────────────┐
        │               block                                    │
        │ ┌────────┐  ┌─────────────┐ ┌───────────────────────┐  │
        │ │ frame0 │  │frame1       │ │  frame2               │  │
        │ └────────┘  └─────────────┘ └───────────────────────┘  │
        └────────────────────────────────────────────────────────┘

而每个内存块会拥有一个头部(`struct tpacket_block_desc`)
该内存块会在开头填入这样一个结构体，然后内核将数据包存储到内存块当中，直到他被填充满,然后将内核`block_status`字段设置为`TP_STATUS_USER`,
这表示用户可以从内存块当中读取数据了，当读取完毕后再将`TP_STATUS_KERNEL`,
然后释放内存块，归还给内核使用

```c
struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};
union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};
struct tpacket_hdr_v1 {
	__u32	block_status;			// 标识内存块目前是否正在被内核使用, 能否提供给用户读取
	__u32	num_pkts;
	__u32	offset_to_first_pkt;
	...
};
```
下面就是块的头部


        ┌───────────────────────────────────────────┐
        │       struct tpacket_block_desc           │
        │  ┌─────────────────────────────────────┐  │
        │  │        tpacket_bd_header_u          │  │
        │  │       ┌─────────────────────┐       │  │
        │  │       │    block_status     │       │  │
        │  │       └─────────────────────┘       │  │
        │  └─────────────────────────────────────┘  │
        ┌───────────────────────────────────────────┐
        │                                           │
        │              block body                   │
        │                                           │
        └───────────────────────────────────────────┘

然后帧也存在头部`tpacket3_hdr`,其中的字段`tpacket3_hdr->tp_next_offset`则指向一个内存块中的写一个帧
```c
struct tpacket3_hdr {
	__u32		tp_next_offset;			// 指向同一个内存块中的下一个帧
	__u32		tp_sec;
	__u32		tp_nsec;
	__u32		tp_snaplen;
	__u32		tp_len;
	__u32		tp_status;
	__u16		tp_mac;
	__u16		tp_net;
	/* pkt_hdr variants */
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8		tp_padding[8];
};
```

如下图,注意这里的箭头并不是指针，只是为了形象化offset关系

            ┌────┐    ┌──────────┐
            │    ▼    │          ▼
      ┌─────┴────┌────┴──────────┌─────────────────┐
      │ frame0   │      frame1   │      frame2     │
      └──────────└───────────────└─────────────────┘



# AF_PACKET 套接字具体实现
每创建一个数据包套接字，内核就会分配一个`packet_sock`结构体

```c
struct packet_sock {
	/* struct sock has to be the first member of packet_sock */
	struct sock		sk;
	struct packet_fanout	*fanout;
	union  tpacket_stats_u	stats;
	struct packet_ring_buffer	rx_ring;			// 接收receive的环形缓冲区，通过setsockopt(..., PACKET_RX_RING, ...)创建。 // ！！！如下
	struct packet_ring_buffer	tx_ring;			// 传输transmit的环形缓冲区，通过setsockopt(..., PACKET_TX_RING, ...)创建。
	...
	enum tpacket_versions	tp_version;				// 环形缓冲区的版本，可通过 setsockopt(..., PACKET_VERSION, ...)设置版本。
	...
	int			(*xmit)(struct sk_buff *skb);
	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
};

// packet_ring_buffer —— https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/internal.h#L56
struct packet_ring_buffer {
	struct pgv		*pg_vec;						// 指向pgv结构体数组的一个指针，数组中的每个元素都保存了对某个内存块的引用。每个内存块实际上都是单独分配的，没有位于一个连续的内存区域中
	...
	struct tpacket_kbdq_core	prb_bdqc;			// 0x30 tpacket_kbdq_core结构体描述了环形缓冲区的当前状态。 // ！！！如下
};

struct pgv {
	char *buffer;               //一个pgv保存一个指向block的指针
};

// tpacket_kbdq_core —— https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/internal.h#L14
struct tpacket_kbdq_core {
	...
	unsigned short	blk_sizeof_priv;				// 包含每个内存块所属的私有区域的大小。 由用户参数 tpacket_req3->tp_sizeof_priv 传过来, unsigned int -> unsigned short
	...
	char		*nxt_offset;						// 指向当前活跃的内存块的内部区域，表明下一个数据包的存放位置。
	...
	struct timer_list retire_blk_timer;				// timer_list结构体，用来描述超时发生后停用当前内存块的那个计时器
};

// timer_list —— https://elixir.bootlin.com/linux/v4.10.6/source/include/linux/timer.h#L12
struct timer_list {
	struct hlist_node	entry;
	unsigned long		expires;
	void			(*function)(unsigned long);
	unsigned long		data;
	u32			flags;
};
```

具体实现如下：


                                        packet_sock
    
                   ┌──────────────────────────────────────────────────────────┐
                   │    packet_ring_buffer rx       packet_ring_buffer tx     │  
                   └──┬────────────────┬──────────────────────────────────────┘
             ┌────────┤     pg_vec     │
             ▼        └────────────────┘
             ┌────────┌───────┌───────┐────────┐
             │  pgv_0 │ pgv_1 │ pgv_2 │ pgv_*  │
             └───┬────└─────┬─└───────┘────────┘
                 │          │
                 ▼          ▼
         ┌───────────┐   ┌───────────┐
         │  block_0  │   │  block_1  │
         └───────────┘   └───────────┘

# 环形缓冲区的设置
内核函数调用`packet_setsockopt()`来设置缓冲区


当使用`PACKET_VERSION`套接字选项的时候，内核会将`po->tp_version`参数的值设置为对应值
然后使用`PACKET_RX_RING`套接字选项，将创建一个用于数据包接受的环形缓冲区,
环形缓冲区对应的设置来源于`struct tpacket_req3`


```c
/* 创建ringbuffer */
static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
		int closing, int tx_ring)
{
    ...

	if (req->tp_block_nr) {

        ...

		case TPACKET_V3:
			po->tp_hdrlen = TPACKET3_HDRLEN;
			break;
		}

    ...

		order = get_order(req->tp_block_size);
    /* 分配packet_sock的pg_vec,也就是存放block指针的数组 */
		pg_vec = alloc_pg_vec(req, order);
		if (unlikely(!pg_vec))
			goto out;
		switch (po->tp_version) {
		case TPACKET_V3:
		/* Transmit path is not supported. We checked
		 * it above but just being paranoid
		 */
			if (!tx_ring)
                /* 初始化接受数据包的TPACKET_V3 ring_buffer->prb_bdqc 内容 */
				init_prb_bdqc(po, rb, pg_vec, req_u);
			break;
		default:
			break;
		}
	}

...
}
```

接下来看其中创建ring buffer的函数

```c
static void init_prb_bdqc(struct packet_sock *po,
			struct packet_ring_buffer *rb,
			struct pgv *pg_vec,
			union tpacket_req_u *req_u)
{
	struct tpacket_kbdq_core *p1 = GET_PBDQC_FROM_RB(rb);
	struct tpacket_block_desc *pbd;

	memset(p1, 0x0, sizeof(*p1));

	p1->knxt_seq_num = 1;
	p1->pkbdq = pg_vec;
	pbd = (struct tpacket_block_desc *)pg_vec[0].buffer; //pdb指向第一个pgv内存
	p1->pkblk_start	= pg_vec[0].buffer;
	p1->kblk_size = req_u->req3.tp_block_size;
	p1->knum_blocks	= req_u->req3.tp_block_nr;
	p1->hdrlen = po->tp_hdrlen;
	p1->version = po->tp_version;
	p1->last_kactive_blk_num = 0;
	po->stats.stats3.tp_freeze_q_cnt = 0;
	if (req_u->req3.tp_retire_blk_tov)
		p1->retire_blk_tov = req_u->req3.tp_retire_blk_tov; //设置停用内存块的计时器
	else
		p1->retire_blk_tov = prb_calc_retire_blk_tmo(po,
						req_u->req3.tp_block_size);
	p1->tov_in_jiffies = msecs_to_jiffies(p1->retire_blk_tov);
	p1->blk_sizeof_priv = req_u->req3.tp_sizeof_priv;

	p1->max_frame_len = p1->kblk_size - BLK_PLUS_PRIV(p1->blk_sizeof_priv);
	prb_init_ft_ops(p1, req_u);
	prb_setup_retire_blk_timer(po); 
	prb_open_block(p1, pbd);        //初始化pbd,也就是刚刚指向的第一个内存块
}

static void prb_open_block(struct tpacket_kbdq_core *pkc1,
	struct tpacket_block_desc *pbd1)
{
    ...

	pkc1->pkblk_start = (char *)pbd1;
    /* 设置下一块的偏移 */
	pkc1->nxt_offset = pkc1->pkblk_start + BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);  

    ...
}

```


这里也很简单那就是给`rb->prb_bdqc`赋值，这个结构体在上面标识过,
作用是是管理`pg_vec`块数组的内容

# 数据接收
内核调用`tpacket_rcv()`来接受数据包,
每当内核接受到新的数据包，就会将其保存到环形缓冲区当中
关键函数为`__packet_lookup_frame_in_block()`,
该函数的主要工作如下:
1. 检查活跃内存块是否有充足的空间存放数据包
2. 如果空间足够那么保存数据包到当前内存块，然后返回
3. 如果空间不够则调度到下一个内存块，保存数据到调度的内存块

```c
static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
               struct packet_type *pt, struct net_device *orig_dev)
{
    ...
    h.raw = packet_current_rx_frame(po, skb, TP_STATUS_KERNEL, (macoff+snaplen)); 	// (1)计算传入的 tp_sizeof_priv, 以控制伪造写入的地址 !!!!
    ...
    skb_copy_bits(skb, 0, h.raw + macoff, snaplen);					// (2)拷贝时产生溢出 !!!!!!!!!!!!!!
    ...
}

static void *packet_current_rx_frame(struct packet_sock *po,						// (1-2)
                        struct sk_buff *skb,
                        int status, unsigned int len)
{
    char *curr = NULL;
    switch (po->tp_version) {
    ...
    case TPACKET_V3:
        return __packet_lookup_frame_in_block(po, skb, status, len);
    ...
    }
}

// __packet_lookup_frame_in_block —— 返回当前缓冲区中可接收数据的起始地址					// (1-3)
static void *__packet_lookup_frame_in_block(struct packet_sock *po,
                        struct sk_buff *skb,
                        int status,
                        unsigned int len
                        )
{
    struct tpacket_kbdq_core *pkc;
    struct tpacket_block_desc *pbd;
    char *curr, *end;
    pkc = GET_PBDQC_FROM_RB(&po->rx_ring);   //pkc为管理pg_vec数组的数据结构体
    pbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);
    ...
    curr = pkc->nxt_offset;  //获取当前使用到的内存块地址
    pkc->skb = skb;
    end = (char *)pbd + pkc->kblk_size;
    /* first try the current block */
    if (curr+TOTAL_PKT_LEN_INCL_ALIGN(len) < end) { 								// (1-4)不满足本条件，所以会从第2个块中找空余的空间。
        prb_fill_curr_block(curr, pkc, pbd, len);
        return (void *)curr;
    }
    /* Ok, close the current block */
    prb_retire_current_block(pkc, po, 0);
    /* Now, try to dispatch the next block */
    curr = (char *)prb_dispatch_next_block(pkc, po); // 返回第2个块
    if (curr) {
        pbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);
        prb_fill_curr_block(curr, pkc, pbd, len);
        return (void *)curr;
    }
    ...
}

static void *prb_dispatch_next_block(struct tpacket_kbdq_core *pkc,
        struct packet_sock *po)
{
    ...
    prb_open_block(pkc, pbd);
    return (void *)pkc->nxt_offset;
}


```

在查找到了合适填入的地址之后，就会调用`skb_copy_bits()`来赋值内容
```c
int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
{
    	int start = skb_headlen(skb);
	struct sk_buff *frag_iter;
	int i, copy;

	if (offset > (int)skb->len - len)
		goto fault;

	/* Copy header. */
	if ((copy = start - offset) > 0) {
		if (copy > len)
			copy = len;
		skb_copy_from_linear_data_offset(skb, offset, to, copy); // (2-1) memcpy(to, skb->data + offset, len);  开始拷贝用户传入的数据，在这里下断点，查看是否覆盖了伪造的数据
		if ((len -= copy) == 0)
			return 0;
		offset += copy;
		to     += copy;
	}
    ...
    if ((copy = end - offset) > 0) {
			u8 *vaddr;

			if (copy > len)
				copy = len;

			vaddr = kmap_atomic(skb_frag_page(f));
			memcpy(to,
			       vaddr + f->page_offset + offset - start,
			       copy);
...
```

# 漏洞点

漏洞点位于`packet_set_ring()`函数
```c
// https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/af_packet.c#L4179
// 该检查可绕过
		if (po->tp_version >= TPACKET_V3 &&
		    (int)(req->tp_block_size -
			  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
			goto out;
```
这里的检查是为了保证每个内存块的头部加上内存块的主体数据不能超过用户所设置的`tp_block_size`
那么这里我们就可以设置`req_u->req3.tp_sizeof_priv`的高位来绕过这一部分
这里给出bsauce师傅的例子
```
A = req->tp_block_size = 4096 = 0x1000
B = req_u->req3.tp_sizeof_priv = (1 << 31) + 4096 = 0x80001000
BLK_PLUS_PRIV(B) = (1 << 31) + 4096 + 48 = 0x80001030
A - BLK_PLUS_PRIV(B) = 0x1000 - 0x80001030 = 0x7fffffd0
(int)0x7fffffd0 = 0x7fffffd0 > 0
```

之后在`init_prb_bdqc()`函数当中,会将`tpacket_kbdq_core`结构体的`blk_sizeif_priv`设置为用户传递的大小,因此我们可以通过绕过上面的判断来直接传入一个极大值，这样就会导致我们能够往一个block中写入大量的值从而造成堆空间越界

```c
// init_prb_bdqc()
static void init_prb_bdqc(struct packet_sock *po,
			struct packet_ring_buffer *rb,
			struct pgv *pg_vec,
			union tpacket_req_u *req_u)
{
	struct tpacket_kbdq_core *p1 = GET_PBDQC_FROM_RB(rb);
	struct tpacket_block_desc *pbd;
	...
	p1->blk_sizeof_priv = req_u->req3.tp_sizeof_priv;						// 此时blk_sizeof_priv刚被赋值。

	p1->max_frame_len = p1->kblk_size - BLK_PLUS_PRIV(p1->blk_sizeof_priv);	// （1）用来设置max_frame_len变量的值。p1->max_frame_len的值代表可以保存到内存块中的某个帧大小的最大值。由于我们可以控制p1->blk_sizeof_priv，我们可以使BLK_PLUS_PRIV(p1->blk_sizeof_priv)的值大于p1->kblk_size的值。这样会导致p1->max_frame_len取的一个非常大的值，比内存块的大小更大。这样当某个帧被拷贝到内存块中时，我们就可以绕过对它的大小检测过程，最终导致内核堆越界写入问题。
	prb_init_ft_ops(p1, req_u);
	prb_setup_retire_blk_timer(po);
	prb_open_block(p1, pbd);
}
```
这里看到当`p1->blk+sizeof_priv`被设置为我们传递的`tp_sizeof_priv`,由上面我们可以得知，
此时可以传递一个高位的值，绕过最初的检测，然后这里赋值过去

最下面的赋值`p1->max_frame_len`当中，由于这里没有检查，我们可以使得`BLK_PLUS_PRIV(p1->blk_sizeof_priv)`的值大于`p1->kblk_size`,
这样就可以造成frame的越界写入


# 漏洞利用
由于我们可以通过计算来控制溢出的字节，
所以这里选取`packet_sock`结构体作为溢出的对象，

1. 将一个接收环形缓冲区附加到packet_sock对象之后，以设置一个内存块停用计时器；
2. 溢出这个内存块，覆盖retire_blk_timer字段。使得retire_blk_timer->func指向native_write_cr4，并且使得retire_blk_timer->data的值与所需的CR4寄存器值相等；
3. 等待计时器执行，就会执行`native_write_cr4(data)`函数

在修改cr4之后关闭掉`SMAP, SMEP`,此时再次使用同样的方法进行溢出，来达成ret2usr攻击

1. 溢出到packet_sock对象的`xmit`函数指针,然后传递用户态构建的函数指针获取root权限
2. xmit函数在发送数据包的时候将会调用


# 参考
[https://bsauce.github.io/2021/05/19/CVE-2017-7308/#3-2-%E6%8E%A7%E5%88%B6%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE](https://bsauce.github.io/2021/05/19/CVE-2017-7308/#3-2-%E6%8E%A7%E5%88%B6%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE)
[https://github.com/duowen1/Container-escape-exps/blob/main/CVE-2017-7308/readme.md](https://github.com/duowen1/Container-escape-exps/blob/main/CVE-2017-7308/readme.md)

