# angr中的仿真管理

# 步进
simulation manager中的最基本功能：
将给定的所有states都向前推进一个basic block,可以使用`.step()`完成这个工作

```py
>>> state = proj.factory.entry_state()
>>> simgr = proj.factory.simgr(state)
>>> simgr.active
[<SimState @ 0x401060>]
>>> simgr.step()
<SimulationManager with 1 active>
>>> simgr.active
[<SimState @ 0x500000>]
```

根据官网所讲，这个simgr的强大之处在于当碰到分支之后，后继状态都将存放在stash当中，并且同样可以同步执行他们

```py
>>> while len(simgr.active) == 1:
...     simgr.step()
...     
<SimulationManager with 1 active>
<SimulationManager with 1 active>
<SimulationManager with 2 active>
>>> simgr
<SimulationManager with 2 active>
>>> simgr.active
[<SimState @ 0x40119e>, <SimState @ 0x401239>]
```



如果你并不是非常仔细的控制分析，只是想单步执行到没有步骤，则可以简单的使用`.run()`方法
```py
>>> simgr.run()
<SimulationManager with 6 deadended>
>>> simgr.active
[]
```
这里便为deadended说明这三个state都达到了exit的syscall,程序就将state从active stash存放在deadended stash当中

# stash管理
可以使用`.move()`函数来在不同的stash当中移动
该函数需要参数`from_stash, to_stash, filter_func`, 
其中`filter_func`是可选的,默认移动所有的内容

每个stash是一个列表，因此你可以使用下面的方式来遍历他们
```py
>>> for s in simgr.deadended:
...     print(hex(s.addr))
...     
0x601050
0x601050
0x601050
0x601050
0x601050
0x601050
```
你可以在每个stash前面加上`one_`,这样你将获得stash中的第一个状态
如果在stash前面加上`mp_`,那么你将获得一个多路复用的stashes


# Stash的类型
|stash类型| 描述|
|--|--|
|active|包含即将步进的state|
|deadended|state由于某种原因无法继续执行|
|pruned|使用`LAZY_SOLVES`时|
|unconstrained|将state标识为不受约束|
|unsat|确定为不满足的状态|
|errored|如果执行时出现错误，则state将被包装成ErrorRecord然后记录到errored当中|

# 简单explore
符号执行中的极其常见的作用是找到某个地址的状态,
同时丢弃通过另一个地址的所有状态
让我们来了解这个`.explore()`方法

我们可以使用`find`参数输入到`.exprore()`方法中，知道找到与find条件匹配的状态
该条件可以是：
1. 要停止的指令的地址
2. 要停止的指令的地址
3. 接受状态并返回它是否满足某些条件的函数

当active中任何状态与find条件匹配的时候，他们将被放置到`found` stash中
当执行终止后，你可以浏览found状态

你同时可以制定`avoid`条件，如果状态和avoid条件匹配，则他们将被放入`avoid` stash当中并继续执行,

最后`num_find`参数控制在返回之前应找到的状态书，默认为1

可以通过例子输出
```py

>>> proj = angr.Project('./test', auto_load_libs=False)
>>> simgr = proj.factory.simgr()
>>> simgr.explore(find = lambda s: b"Nice!" in s.posix.dumps(1))
<SimulationManager with 1 active, 4 deadended, 1 found>
```
然后发现found stash里面已经出现了结果，那么我们可以通过`found`列表来查看输入和输出
```py

>>> s = simgr.found[0]
>>> print(s.posix.dumps(1))
b'Nice!\n'
>>> flag = s.posix.dumps(0)
>>> print(flag)
b'00000000160000000017000000001800000000190000000020'
```

# 探索技巧
可以查看官方文档获取相关配置，其中就比如有深度遍历的设置



# 参考
[https://docs.angr.io/en/latest/core-concepts/pathgroups.html](https://docs.angr.io/en/latest/core-concepts/pathgroups.html)

