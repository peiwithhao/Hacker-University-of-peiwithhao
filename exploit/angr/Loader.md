# Loader
这里主要详细学习加载这一部分
CLE表示CLE Loads Everthing,CLE负责加载二进制内容和他依赖的任何库

```py
>>> proj = angr.Project('./test')
>>> proj.loader
<Loaded test, maps [0x400000:0xa07fff]>
```
而这个loader变量存在许多有用的字段

1. `all_objects`: 获取加载的所有objects
2. `main_object`: 获取main object，也就是你制定的项目程序
3. `shared_objects`: 映射到的共享object的字典
4. `all_elf_objects`: 加载的所有elf文件
5. `all_pe_objects`: 加载的所有pe文件
6. `extern_object`: 还没有被映射到的地区
7. `kernel_object`: 系统调用入口的映射
8. `find_object_containing(0x40000)`: 寻找某个地址所映射的object

## main_object
他拥有字段以及功能如下：
1. `entry`: object的入口点
2. `min_addr, max_addr`: 获取最小和映射最大地址
3. `segments`: 获取段空间
4. `sections`: 获取节空间
5. `find_segment_containing()`: 寻找指定地址的段
6. `find_section_containing()`: 寻找指定地址的节
7. `obj.plt['puts']`: 寻找制定plt地址
8. `obj.linked_base`: 显示object预链接的地址
9. `obj.mapped_base`: 显示object实际映射的地址
10. `get_symbol`: 获取当前object的对象

## find_symbol()
可以使用它来获取符号对象
```py
>>> proj.loader.find_symbol('puts')
<Symbol "puts" in libc.so.6 at 0x582360>
```
他拥有字段如下:
1. `name`: 获取符号名称
2. `owner`: 获取所属object
3. `rebased_addr`: 在全局地址空间的地址
4. `linked_addr`: 在二进制代码中的地址偏移
5. `relative_addr`: 相对于object的地址
6. `is_export`: 查看是否是导出函数
7. `is_import`: 查看是否是导入


## shared_objects

获取共享object,可以使用它的字段`imports`来获取导出函数
```py
>>> proj.loader.shared_objects['libc.so.6'].imports
{'_dl_argv': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac49e50>,
 '__rseq_offset': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac4a030>,
 '_dl_find_dso_for_object': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac2d090>,
 '__libc_enable_secure': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac2d310>,
 '_dl_deallocate_tls': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac2d590>,
 '__tls_get_addr': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac091d0>,
 '__libc_stack_end': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac09950>,
 '_rtld_global_ro': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac085f0>,
 '_dl_signal_error': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac093b0>,
 '_dl_fatal_printf': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac08690>,
 '_dl_signal_exception': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac09310>,
 '_dl_audit_symbind_alt': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b390>,
 '__rseq_size': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b1b0>,
 '__tunable_is_initialized': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b430>,
 '_dl_rtld_di_serinfo': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b610>,
 '_dl_allocate_tls': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b890>,
 '__tunable_get_val': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0bb10>,
 '_dl_catch_exception': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0b930>,
 '_dl_allocate_tls_init': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac0bcf0>,
 '_rtld_global': <cle.backends.elf.relocation.amd64.R_X86_64_64 object at 0x798edad2f8a0>,
 '_dl_audit_preinit': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT object at 0x798edac08230>}
```
# 加载选项
+ `auto_load_libs`: 默认打开,这里是默认加载依赖库，追求效率可以手动指定false
+ `except_missing_libs`: 默认关闭， 
可以手动选择打开，启用后当遇到无法加载的共享库则会爆出异常
+ `force_load_libs`: 可以传递字符串列表，列出的任何内容都将立即被视为未解析的共享库依赖，
+ `main_opts`, `lib_opts`: 仅仅适用于特定二进制对象的选项,其中`main_opts`的映射是选项名到选项值， 而`lib_opts`则是从库名称到(选项名到选项值字典)的映射
其中一些常见的选项名如下:
    + `backend`: 使用的backend作为类或名称
    + `base_addr`: 要使用的基地址
    + `entry_point`: 指定的入口点
    + `arch`: 指定架构


这里给出官方的例子：
```py
angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})
```


# 参考
[https://docs.angr.io/en/latest/core-concepts/loading.html](https://docs.angr.io/en/latest/core-concepts/loading.html)
