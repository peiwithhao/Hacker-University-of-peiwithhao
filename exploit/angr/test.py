import angr, monkeyhex


# 定义 hook 处理 syscall
def syscall_hook(state):
    syscall_num = state.regs.eax  # x86 下 syscall 号在 eax
    # print(f"Intercepted syscall: {syscall_num}")
    syscall_set[syscall_num] = len(state.history.bbl_addrs.hardcopy)
    # syscall_set.append(syscall_num)



proj = angr.Project("./libc.so.6", auto_load_libs=False)
write_addr = proj.loader.find_symbol('__isoc23_scanf').rebased_addr
print(hex(write_addr))


state = proj.factory.blank_state(addr = write_addr)
# state = proj.factory.call_state(write_addr, )

syscall_set = {}




state.inspect.b('syscall', when=angr.BP_BEFORE, action=syscall_hook)

# 运行符号执行
simgr = proj.factory.simgr(state)
# simgr.use_technique(angr.exploration_techniques.DFS())


# simgr.max_depth = 50
'''
while len(simgr.active):
    simgr.step()
    if len(simgr.active) > 2:
        simgr.active = simgr.active[1:]  # 只保留前 5 条
'''

simgr.run()
# simgr.explore(find=lambda s: s.history.jumpkind == "Ijk_Syscall")
print(syscall_set)

