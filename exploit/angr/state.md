# 学习state
在最开始的基本操作已经学习到了如何通过state获取一些基本信息例如寄存器和内存的值

# 基本执行
可以简单的使用指令`state.step()`来进行符号执行,
这个符号执行将返回一个名为`angr.engines.successors.SimSuccessors`的对象
这里并不等同于普通的仿真，而是产生多个后继状态

这里给出一个场景:
1. 碰到条件语句if (x > y)
2. angr生成对应AST
3. 生成两种状态states,第一个模拟为true,那么true的约束条件变为`x > y`,
而第二个模拟为false,那么false的约束条件变为`!(x > y)`

下面给出示例
```py
>>> state = proj.factory.entry_state(stdin=angr.SimFile)
>>> while True:
...     succ = state.step()
...     if len(succ.successors) == 2:
...         break
...     state = succ.successors[0]
...     
>>> state1, state2 = succ.successors
>>> state1
<SimState @ 0x40119e>
>>> state2
<SimState @ 0x401239>
```
# state presets
除了`proj.factory.entry_state()`之外还有其他的预设状态可以设置:
1. `.blank_state()`: 
构造空白状态，此时大部分数据未初始化，
访问未初始化数据将会返回一个不受约束的符号值
2. `.entry_state()`:
构造主程序的入口点执行的状态
3. `.full_init_state()`:
构造一个状态，该状态在准备好初始化阶段, 执行完这些初始化立刻跳转到入口点
3. `.call_state()`:
构造一个准备执行给定函数的状态

这些预定状态还支持客制化参数:
+ 这些函数都接受`addr`参数来制定开始的确切地址
+ 如果需要接受命令行参数或特定环境条件，可以通过`args`参数列表传递和环境变量字典通过`env`参数传递到`entry_state()`或`full_init_state()`
+ 如果想让`argc`是符号的，你可以将符号位向量作为`argc`传递给`entry_state()`或是`full_init_state()`,但是这里你需要将结果状态添加一个约束那就是argc的值不能大于你传递给`args`的args数量
+ 可以通过`call_state(addr, arg1, arg2, ...)`来调用


# 参考
[https://docs.angr.io/en/latest/core-concepts/states.html](https://docs.angr.io/en/latest/core-concepts/states.html)


