import angr
import logging

logging.getLogger('angr').setLevel('ERROR')

def get_syscall_name(proj, syscall_num):
    return proj.factory.posix.syscall_names.get(int(syscall_num), f"unknown_syscall_{syscall_num}")

def traverse_cfg_from_entry(proj, cfg, start_addr=None):
    if start_addr is None:
        start_addr = proj.entry  # 默认从程序入口开始

    # 存储系统调用序列
    syscall_sequence = []
    visited = set()

    def dfs(current_node):
        if current_node in visited or not current_node.block:
            return
        visited.add(current_node)

        # 检查当前块的系统调用
        block = current_node.block
        try:
            capstone_block = block.capstone
            for insn in capstone_block.insns:
                if insn.mnemonic in ['syscall', 'int']:
                    addr = insn.address
                    syscall_num = None
                    if insn.mnemonic == 'syscall':
                        for prev_insn in capstone_block.insns[:capstone_block.insns.index(insn)][-3:]:
                            if prev_insn.mnemonic == 'mov' and 'rax' in prev_insn.op_str:
                                try:
                                    syscall_num = int(prev_insn.op_str.split(',')[-1].strip(), 0)
                                    break
                                except ValueError:
                                    pass
                    syscall_name = get_syscall_name(proj, syscall_num) if syscall_num else "unknown_syscall"
                    syscall_sequence.append((addr, syscall_name))
                    print(f"Found syscall at 0x{addr:x}: {syscall_name}")
        except Exception:
            pass

        # 递归遍历后继节点
        for succ in cfg.graph.successors(current_node):
            dfs(succ)

    # 从入口节点开始遍历
    start_node = cfg.get_any_node(start_addr)
    print(start_node)
    if start_node:
        dfs(start_node)
    else:
        print(f"No node found at entry point 0x{start_addr:x}")

    return syscall_sequence

def analyze_syscalls_with_cfg(binary_path):
    proj = angr.Project(binary_path, auto_load_libs=False)
    print("Generating CFG with CFGFast...")
    cfg = proj.analyses.CFGFast()
    print("CFG generation completed.")

    # 从入口点遍历 CFG
    syscall_sequence = traverse_cfg_from_entry(proj, cfg)
    print("==========================")

    # 输出结果
    if not syscall_sequence:
        print("No system calls found in CFG traversal.")
    else:
        print("\nSystem call sequence (from entry):")
        for addr, syscall in syscall_sequence:
            print(f"0x{addr:x}: {syscall}")

    return syscall_sequence

if __name__ == "__main__":
    binary_path = "./test"  # 替换为你的二进制路径
    analyze_syscalls_with_cfg(binary_path)


# print(simgr)



