import angr
import logging

logging.getLogger('angr').setLevel('ERROR')

def get_syscall_name(proj, syscall_num):
    return proj.factory.posix.syscall_names.get(int(syscall_num), f"unknown_syscall_{syscall_num}")

def analyze_block(proj, block, syscall_sequence, visited_funcs):
    """分析基本块中的 syscall 和 call，返回 call 目标地址"""
    call_targets = []
    try:
        capstone_block = block.capstone
        for insn in capstone_block.insns:
            if insn.mnemonic == 'syscall':
                syscall_num = None
                for prev_insn in capstone_block.insns[:capstone_block.insns.index(insn)][-3:]:
                    if prev_insn.mnemonic == 'mov' and 'rax' in prev_insn.op_str:
                        try:
                            syscall_num = int(prev_insn.op_str.split(',')[-1].strip(), 0)
                            break
                        except ValueError:
                            pass
                syscall_name = get_syscall_name(proj, syscall_num) if syscall_num else "unknown_syscall"
                syscall_sequence.append((insn.address, syscall_name))
                print(f"Found syscall at 0x{insn.address:x}: {syscall_name}")
            elif insn.mnemonic == 'call':
                target_addr = int(insn.op_str, 16) if insn.op_str.startswith('0x') else None
                if target_addr and proj.loader.main_object.contains_addr(target_addr):
                    if target_addr not in visited_funcs:  # 避免循环调用
                        print(f"Found call at 0x{insn.address:x} to 0x{target_addr:x}")
                        call_targets.append(target_addr)
    except Exception:
        pass
    return call_targets

def traverse_function_subgraph(proj, cfg, func_addr, syscall_sequence, visited_funcs=None):
    """递归遍历函数的 CFG 子图，收集系统调用"""
    if visited_funcs is None:
        visited_funcs = set()
    if func_addr in visited_funcs:
        return
    visited_funcs.add(func_addr)

    start_node = cfg.get_any_node(func_addr)
    if not start_node:
        print(f"No node found at 0x{func_addr:x}")
        return

    visited_nodes = set()

    def dfs(node):
        if node in visited_nodes or not node.block:
            return
        visited_nodes.add(node)

        # 分析当前块
        call_targets = analyze_block(proj, node.block, syscall_sequence, visited_funcs)

        # 递归分析 call 目标
        for target_addr in call_targets:
            print(f"Entering function at 0x{target_addr:x}")
            traverse_function_subgraph(proj, cfg, target_addr, syscall_sequence, visited_funcs)

        # 遍历后继节点
        for succ in cfg.graph.successors(node):
            dfs(succ)

    print(f"Starting traversal of function at 0x{func_addr:x}")
    dfs(start_node)

def analyze_libc_write_syscalls(libc_path):
    # 加载 libc.so.6
    proj = angr.Project(libc_path, auto_load_libs=False)
    print("Generating CFG with CFGFast...")
    cfg = proj.analyses.CFGFast()
    print("CFG generation completed.")

    # 定位 write 函数
    write_symbol = proj.loader.main_object.get_symbol("main")
    if not write_symbol:
        print("Error: 'write' symbol not found in libc.so.6")
        return []
    write_addr = write_symbol.rebased_addr
    print(f"Found 'write' at 0x{write_addr:x}")

    # 遍历 write 的子图并收集系统调用
    syscall_sequence = []
    traverse_function_subgraph(proj, cfg, write_addr, syscall_sequence)

    # 输出结果
    if not syscall_sequence:
        print("No system calls found in write's subgraph.")
    else:
        print("\nSystem call sequence in write's subgraph:")
        for addr, syscall in syscall_sequence:
            print(f"0x{addr:x}: {syscall}")

    return syscall_sequence

if __name__ == "__main__":
    libc_path = "./test"  # 替换为你的 libc.so.6 路径
    analyze_libc_write_syscalls(libc_path)
