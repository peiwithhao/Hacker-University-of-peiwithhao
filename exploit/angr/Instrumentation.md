# Instrumentation.md

# 仿真与检测
当使用angr在模拟执行某条指令的时候，必须有实际处理的过程，
那么处理这个过程的是angr使用的一系列engine(他们都是SimEngine的子类)

有下面集中engine分类
+ `failure engine`: 当执行到无法执行的地步,该engine启动
+ `syscall engine`: 当上一步以syscall结束启动
+ `hook engine`: 当前地址被hook时启动
+ `unicorn engine`: 当启用unicorn state并且没有符号数据时启动
+ `VEX engine`: 最终回退时启动

# SimSuccessors


> [!caution]
> 下面这部分并没有怎么看懂,仅仅是对照官网翻译


而这里依次尝试所有引擎的代码是`proj.factory.successors(state, **kwargs)`
而这段代码是`state.step()`和`simgr.step()`的核心
该代码返回一个`SimSuccessors`对象,这个对象的主要目的是对存储在各种list state中的后继状态进行简单分类
分别有下面几种分类：
|属性|保护条件|指令指针|描述|
|--|--|--|--|
|successors|True|可以是符号|正常的后继状态|
|unsat_successors|False|可以是符号|不满足的后继状态|
|flat_successors|True|具体值|扁平化，不知道在说什么|
|unconstrained_successors|True|Symbolic|如果扁平化炒作256个解决方案，则将其放置在其中|
|all_successors|Anything|可能是Symbolic|不包括flat的所有后继者集合|




# 参考
[https://docs.angr.io/en/latest/core-concepts/simulation.html](https://docs.angr.io/en/latest/core-concepts/simulation.html)




