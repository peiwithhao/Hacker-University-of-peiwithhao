# Symbolic Experssions and Constraint Solving
Angr的符号执行的基本原理是在程序中需要变量的时候，他并不是仿真具体的输入，
而是包含一个符号,然后使用该变量执行算术运算将产生一个运算树AST,
他可以给出类似于，使用何种输入会导致这种序列的输出

# 使用Bitvectors

首先获取一个模拟state
```py
>>> proj = angr.Project('./test')
>>> state = proj.factory.entry_state()
```
然后我们可以自定义一个bit序列

经过测试发现较新版本的angr已经不再支持BVV
我们直接学习如何创建符号变量
可以用下面的BVS方法
```py
>>> one = state.solver.BVS("one", 64)
>>> print(one)
<BV64 one_57_64>
```
这样下去就创建了一个名叫one的符号变量,
现在可以对这些符号变量进行计算，但得到的只会是一个AST
```py
>>> one + 1
<BV64 one_109_64 + 0x1>
```
每一个AST都会有字段`.op`和`.args`
op字段是一个字符串，用于命名正在执行的操作
而args则是作为输入的值

```py
>>> tree = (x+1)/(y+2)
<python-input-34>:1: DeprecationWarning: Use BV.__floordiv__ instead of BV.__truediv
__
  tree = (x+1)/(y+2)
>>> tree
<BV64 (x_110_64 + 0x1) / (y_111_64 + 0x2)>
>>> tree.op
'__floordiv__'
>>> tree.args
(<BV64 x_110_64 + 0x1>, <BV64 y_111_64 + 0x2>)
```
任意两个类型相似的AST之间进行比较将产生另一个AST- 不是位向量而是一个bool值

# 符号约束
我们可以对state进行符号的约束，如下:
```py
>>> state.solver.add(y>2)
>>> state.solver.add(10 > x)
>>> state.solver.eval(x)
0x5
```
按照官方文档的讲解我们就可以使用符号约束来获取期望结果的输入
```py

>>> state = proj.factory.entry_state()
>>> input = state.solver.BVS('intpu', 64)
>>> operation = (((input + 4) * 3) >> 1) + input
>>> operation
<BV64 ((intpu_112_64 + 0x4) * 0x3 >> 0x1) + intpu_112_64>
>>> output = 199
>>> state.solver.add(operation == output)
>>> state.solver.eval(input)
0xcccccccccccccd1a
```
但该解决方案仅在位向量语义有效，整数域不会有解


# 参考
[https://docs.angr.io/en/latest/core-concepts/solver.html](https://docs.angr.io/en/latest/core-concepts/solver.html)


