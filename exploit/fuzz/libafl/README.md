# libAFL学习
学习libAFL的架构和知识，顺便学一学Rust =)

# 组件相关
libAFL相比于AFL/AFL++来说最大的区别就是他将后者分解开，让用户能更加方便的对于特定目标进行定制化测试

他将其拆解为以下几种组件:
1. State
2. EventManager
3. Fuzzer
4. Scheduler
5. Executor
6. Generator
7. Observer
8. Feedback
9. Objective Feedback
10. Stages

从官方的git仓库中的`baby*`代码来学习  

# baby fuzzer
首先是对于依赖的配置
可以直接使用cargo包管理器来新建一个项目
`cargo new baby_fuzzer`

然后这个目录下就会存放`Cargo.toml`的文件，可以到这个文件下配置依赖

```toml

[package]
name = "baby_fuzzer"
version = "0.1.0"
authors = ["peiwithhao"]
edition = "2024"

[dependencies]
libafl = {path = "/home/peiwithhao/repo/LibAFL/libafl/"}
libafl_bolts = {path = "/home/peiwithhao/repo/LibAFL/libafl_bolts/"}

[profiles.dev]
panic = "abort"


[profiles.release]
panic = "abort"
lto = true
codegen-units = 1
opt-level = 3
debug = true


[features]
panic = []
```

这样就可以在`main.rs`里面使用libafl相关函数(但前提是你已经将这个libafl进行编译)

```rust
extern crate libafl_bolts;
extern crate libafl;
```
类似于import package
这样我们才能使用该包里面的一些函数

开始fuzz之前，我们需要先定下来我们的目标函数，本次的target为使用rust实现的一个函数

```rust

pub fn harness(input: &BytesInput){
    //获取输入,将输入的Vec转换为Slice
    let target = input.target_bytes();
    let buf = target.as_slice();
    if !buf.is_empty() && buf[0] == b'p' {
        if buf.len() > 1 && buf[1] == b'e' {
            if buf.len() > 2 && buf[2] == b'w' {
                if buf.len() > 3 && buf[3] == b'i' {
                    #[cfg(unix)] //用于条件编译
                    /* 这是一个panic报错宏 */
                    panic!("Artificial bug triggered =)");
                }
            }
        }
    }
    /* 正常退出函数 */
    ExitKind:Ok
}
```
然后可以手动测试一下这个harness 

```rust
pub fn main() {
    let input = BytesInput::new(Vec::from("peiwithhao"));

    #[cfg(feature = "panic")]
    /* 测试Harness */
    harness(&input);
}
```
注意这里需要在 `Cargo.toml`里面声明特性 

## State组件

添加代码:
```rust
    /* 声明状态 */
    let mut state = StdState::new(
        //RNG
        /* 使用当前纳秒数作为种子 */
        StdRand::with_seed(current_nanos()),
        //Corpus: 使用内存来保存更新的语料
        InMemoryCorpus::<BytesInput>::new(),
        //Solutions: 保存Solutions
        OnDiskCorpus::new(PathBuf::from("./crashes")).unwrap(),
        &mut (),
        &mut (),
        ).unwrap();
```

这里创建的state包含我们所有用来存放的`corpus, solutions, `等等信息
传递的参数如下:
1. rand: 生成testcase的初始种子
2. corpus: 包含所有测试用例
3. solutions: 触发问题的测试用例
4. feedback: 保存测试用例的规则
5. objective: 划为solutions的规则

暂时这里并没有写feedback和objective,仅仅用来测试，在后面讲到相应板块再添加


## EventManager组件
该组件的功能是处理一些模糊测试过程中的事件，例如向语料库添加语料
这里官方使用了最简单的monitor，仅仅用来打印信息

```rust
    #[cfg(not(feature = "tui"))]
    let mon = SimpleMonitor::new(|s| println!("{s}"));

    #[cfg(feature = "tui")]
    let mon = TuiMonitor::builder()
        .title("Baby Fuzzer")
        .enhanced_graphics(false)
        .build();

    let mut mgr = SimpleEventManager::new(mon);
```

注意使用这个组件需要：
1. 声明monitor
2. 使用monitor来声明EventManager

## Scheduler组件
该组件用来对于调度测试用例的测试顺序,这里官方给出的例子是使用FIFO(First In First Out)策略

```rust

    /* 先进先出队列 */
    let scheduler = QueueScheduler::new();
```

## Fuzzer组件
该组件包含了一些对于状态的改变策略
```rust

    // A fuzzer with feedbacks and a corpus scheduler
    let mut fuzzer = StdFuzzer::new(scheduler, (), ());

```
传递的参数分别为`scheduler, feedback, objective`

## Executor组件
这个组件用来负责运行被测试的实体，官方使用了`InprocessExecutor`,不fork子进程
```rust

    let mut executor = InProcessExecutor::new(
        &mut harness,
        (),
        &mut fuzzer,
        &mut state,
        &mut mgr,
    )
    .expect("Failed to create the Executor");

```
参数分别为`harness_fn, observers, fuzzer, state, eventmgr`
注意这里的executor希望返回的对象是ExitKind, 因此在harness需要返回对应返回值

## Generator组件
用来生成随机的测试用例
```rust
    /* 生成随机的测试用例 */
    let mut generator = RandPrintablesGenerator::new(nonzero!(32));

    state
        .generate_initial_inputs(&mut fuzzer, &mut executor, &mut generator, &mut mgr, 8)
        .expect("Failed to generagte the initial corpus");
```

然后下面是生成了8个测试用例

## Observer组件
基于反馈的模糊测试，这里实现一个简单的测试比例收集

```rust
static mut SIGNALS: [u8; 16] = [0; 16];
// TODO: This will break soon, fix me! See https://github.com/AFLplusplus/LibAFL/issues/2786
#[allow(static_mut_refs)] // only a problem in nightly
static mut SIGNALS_PTR: *mut u8 = unsafe { SIGNALS.as_mut_ptr() };

fn signals_set(idx: usize) {
    unsafe { write(SIGNALS_PTR.add(idx), 1) };
}

pub fn main(){

    let mut harness = |input :&BytesInput|{
    //获取输入,将输入的Vec转换为Slice
        let target = input.target_bytes();
        let buf = target.as_slice();
        if !buf.is_empty() && buf[0] == b'p' {
            if buf.len() > 1 && buf[1] == b'e' {
                if buf.len() > 2 && buf[2] == b'w' {
                    if buf.len() > 3 && buf[3] == b'i' {
                        #[cfg(unix)] //用于条件编译
                        /* 这是一个panic报错宏 */
                        panic!("Artificial bug triggered =)");
                    }
                }
            }
        }
        /* 正常退出函数 */
        ExitKind::Ok
        
    }; 

...
    let mut observer = unsafe{ StdMapObserver::from_mut_ptr("signals", SIGNALS_PTR, SIGNALS.len()) };
...
```

## Feedback组件
该组件用来判断某次输入的测试用例和相应的执行状态是否有趣,如果有趣则加入到语料库当中
而官方使用到的feedback为最大Mapfeedback
```rust

    // Feedback to rate the interestingness of an input
    let mut feedback = MaxMapFeedback::new(&observer);
```

## Objective组件
用来决定结果是否为solutions，如果是则保存到solutions的corpus当中

## Stages组件
实际的模糊测试需要不断变异我们的输入，而这就需要当前的Mutator,和stages来不断对corpus的输入来执行操作

```rust

    let mutator = HavocScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

```

最后使用`fuzzer.fuzz_loop`来激活stages

```rust

    fuzzer
        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)
        .expect("Error in the fuzzing loop");
```



