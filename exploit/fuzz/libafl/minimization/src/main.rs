use clap::{Parser};
use libafl::{corpus::{InMemoryCorpus, InMemoryOnDiskCorpus, OnDiskCorpus}, events::SimpleEventManager, executors::{forkserver::ForkserverExecutorBuilder, ForkserverExecutor, InProcessExecutor}, feedback_and_fast, feedback_or, feedbacks::{CrashFeedback, MaxMapFeedback, TimeFeedback}, inputs::BytesInput, monitors::SimpleMonitor, mutators::{tokens_mutations, HavocScheduledMutator, Tokens}, observers::{CanTrack, HitcountsMapObserver, StdMapObserver, TimeObserver}, schedulers::{IndexesLenTimeMinimizerScheduler, QueueScheduler}, stages::{StdMutationalStage, StdTMinMutationalStage}, state::StdState, Error, StdFuzzer};
use libafl_bolts::{current_nanos, rands::StdRand, shmem::{ShMemProvider, UnixShMemProvider}, tuples::{tuple_list, tuple_list_type}};
use std::path::PathBuf;
use nix::sys::signal::Signal;
// use libafl_bolts::os::unix_signals::Signal;
use libafl_bolts::shmem::ShMem;
use libafl_bolts::AsSliceMut;
use libafl_bolts::tuples::Handled;
use libafl_bolts::TargetArgs;
use libafl::state::HasCorpus;
use libafl_bolts::tuples::Merge;
use libafl::Fuzzer;
use libafl::corpus::Corpus;
use std::time::Duration;
use libafl::executors::HasObservers;
use libafl_bolts::Truncate;
use libafl::HasMetadata;
use libafl::mutators::havoc_mutations;
use libafl::state::HasSolutions;
use libafl::stages::StagesTuple;
use libafl::corpus::HasCurrentCorpusId;


#[derive(Debug, Parser)]
#[command(
    name = "minimization_simple",
    about = "Learn how to build a simple minimization fuzz",
    author = "peiwithhao <peiwithhao@outlook.com>",
)]
struct Opt{
    #[arg(
        help = "target to fuzz",
        name = "EXEC",
        required = true
    )]
    executable: String,

    #[arg(
        help = "The directory for initial inputs",
        short = 'i',
        name = "INPUT_DIR",
        required = true
    )]
    in_dir: PathBuf,

    #[arg(
        help = "The directory for solution outputs",
        short = 'o',
        long = "output_dir",
        default_value = "./crashes",
        // required = true
        )]
    out_dir: PathBuf,

    #[arg(
        help = "Timeout for each individual execution",
        short = 't',
        long = "timeout",
        // in milliseconds
        default_value = "1200"
    )]
    timeout: u64,

    
    #[arg(
        help = "If not set , child's stdout/stderror will be redirect to the /dev/null",
        short = 'd',
        long = "debug-child",
        // in milliseconds
        default_value = "false"
    )]
    debug_child: bool,

    #[arg(
        help = "Arguments passed to the target",
        name = "arguments",
        num_args(1..),
        allow_hyphen_values = true,
    )]
    arguments: Vec<String>,

    #[arg(
        help = "Signal used to stop child",
        short = 's',
        long = "signal",
        value_parser = str::parse::<Signal>,
        default_value = "SIGKILL"
    )]
    signal: Signal,
}


fn main() -> Result<(), Error>{

    const MAP_SIZE:usize = 4096;
    let opt = Opt::parse();
    let corpus_dir:Vec<PathBuf>= [opt.in_dir].to_vec();

    /* 创建共享内存用来存放覆盖率map */
    let mut shmem_provider = UnixShMemProvider::new().unwrap();
    let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap();
    unsafe{
        shmem.write_to_env("__AFL_SHM_ID").unwrap();
    }
    let shmem_buf = shmem.as_slice_mut();

    /* 1. 观察者 */
    let edges_observer = unsafe{
        HitcountsMapObserver::new(StdMapObserver::new("shmem_buffer", shmem_buf)).track_indices()
    };
    let time_observer = TimeObserver::new("times");

    /* 2. feedback */
    let mut feedback = feedback_or!(
        MaxMapFeedback::new(&edges_observer),
        TimeFeedback::new(&time_observer)
        );
    /* 3. objective */
    let mut objective = feedback_and_fast!(
        CrashFeedback::new(),
        MaxMapFeedback::with_name("objective_maxmap_observer", &edges_observer)
        );

    /* 4. state */
    //获取solutions目录
    let solution_dir = opt.out_dir.clone();
    let mut state = StdState::new(
        //RNG
        StdRand::with_seed(current_nanos()),
        //corpus
        InMemoryCorpus::<BytesInput>::new(),
        //solutions
        OnDiskCorpus::new(solution_dir.clone()).unwrap(),
        &mut feedback,
        &mut objective
        ).unwrap();

    /* 5. monitor */
    let mon = SimpleMonitor::new(|s:&str| println!("{:?}", s));
    let mut mgr = SimpleEventManager::new(mon);

    /* 6. Scheduler */
    let scheduler = IndexesLenTimeMinimizerScheduler::new(&edges_observer, QueueScheduler::new());
    
    /* 7. Fuzzer */
    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);

    let debug_child: bool = opt.debug_child.clone();
    let args :Vec<String> = opt.arguments.clone();

    let observer_ref = edges_observer.handle();

    let mut tokens = Tokens::new();
    /* 8. executors */
    let mut executors = ForkserverExecutor::builder()
        .program(opt.executable.clone())
        .debug_child(debug_child)
        .autotokens(&mut tokens)
        .shmem_provider(&mut shmem_provider)
        .parse_afl_cmdline(args)
        .coverage_map_size(MAP_SIZE)
        .timeout(Duration::from_millis(opt.timeout.clone()))
        .kill_signal(opt.signal.clone())
        .build(tuple_list!(time_observer, edges_observer)).unwrap();

    /* 修改mapsize大小 */
    if let Some(coverage_map_cur_size) = executors.coverage_map_size() {
        executors.observers_mut()[&observer_ref]
            .as_mut()
            .truncate(coverage_map_cur_size);
    }

    if state.must_load_initial_inputs(){
        state.load_initial_inputs(
            &mut fuzzer, 
            &mut executors,
            &mut mgr,
            &corpus_dir
            ).unwrap_or_else(|err|{
                panic!("Failed to load initial corpus {:?}\nError Message: {:?}",
                    corpus_dir,
                    err);
        });
        println!("Import {:?} corpus from dir {:?}", state.corpus().count(), corpus_dir);
    }

    state.add_metadata(tokens.clone());

    //添加变异策略，这里的策略是混乱变异和token变异
    let mutator = HavocScheduledMutator::with_max_stack_pow(havoc_mutations().merge(tokens_mutations()), 6);
    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

    while state.solutions().is_empty(){
        fuzzer.fuzz_one(&mut stages, &mut executors, &mut state, &mut mgr).expect("Error in the fuzzing loop");
    }

    let minimized_dir = PathBuf::from("./minimized");


    let mut state = StdState::new(
        //RNG
        StdRand::with_seed(current_nanos()),
        InMemoryOnDiskCorpus::<BytesInput>::new(minimized_dir).unwrap(),
        InMemoryCorpus::new(),
        &mut (),
        &mut ()
        ).unwrap();


    let mon = SimpleMonitor::new(|s| println!("{s}"));

    let mut mgr = SimpleEventManager::new(mon);
    let minimizer = HavocScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(
        StdTMinMutationalStage::new(
            minimizer,
            CrashFeedback::new(),
            1<<10
            )
        );

    let schedulers = QueueScheduler::new();
    let mut fuzzer = StdFuzzer::new(schedulers, (), ());

    let args :Vec<String> = opt.arguments.clone();
    let mut executors = ForkserverExecutor::builder()
        .program(opt.executable.clone())
        .autotokens(&mut tokens)
        .shmem_provider(&mut shmem_provider)
        .parse_afl_cmdline(args)
        .coverage_map_size(MAP_SIZE)
        .timeout(Duration::from_millis(opt.timeout.clone()))
        .kill_signal(opt.signal.clone())
        .build(()).unwrap();

    state.load_initial_inputs_forced(
        &mut fuzzer,
        &mut executors,
        &mut mgr,
        &[solution_dir]
        ).unwrap_or_else(|err|{
        println!("{err}");
    });


    state.set_corpus_id(state.corpus().first().expect("Empty corpus"))?;

    stages.perform_all(&mut fuzzer, &mut executors, &mut state, &mut mgr)?;
    
    Ok(())

}
