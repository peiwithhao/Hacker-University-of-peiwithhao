# Forkserver
在AFL++中我们知道forkserver实际上就是目标程序，
其不断使用fork来创建子进程，以此来减少对于execve的调用从而优化fuzz过程

这里讲解一下forkserver的大致使用
# build.rs
这里需要首先在Cargo.toml中编写对应选项
```rs
[package]
name = "forkserver_simple"
version = "0.1.0"
edition = "2024"
build = "build.rs"
```

这样在进行build的时候
将会在编译主程序前
执行我们需要的操作

```rs

use std::env;
use std::process::Command;
use std::path::PathBuf;
pub fn main(){
    /* 获取路径 */
    let cwd = env::current_dir().unwrap().to_string_lossy().to_string();
    /* 这里也可以通过相对路径 */
    // let afl_cc = format!("{}/AFLplusplus/afl-cc", &cwd);
    // let afl = format!("{}/AFLplusplus", &cwd);

    // let _afl_path = PathBuf::from("afl-clang-fast");
    let afl_cc_path = PathBuf::from("afl-clang-fast");
    let _afl_cxx_path = PathBuf::from("afl-clang-fast++");

    /* 配置命令 */
    let mut compile_command = Command::new(afl_cc_path);
    compile_command
        .args(["src/program.c", "-o"])
        .arg(format!("{}/target/release/program", String::from(cwd)));
    if let Ok(llvm_config) = env::var("LLVM_CONFIG"){
        if !llvm_config.is_empty() {
            compile_command.env("LLVM_CONFIG", llvm_config);
        }
    }
    compile_command.output().unwrap();
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/");

}
```
操作如下:
1. 执行afl编译命令,编译 `src/program.c` 
2. 当build.rs和src/变化时才执行

# harness
本节的harness是使用C语言编写的函数
```rs

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// The following line is needed for shared memeory testcase fuzzing
__AFL_FUZZ_INIT();

void vuln(char *buf) {
  if (strcmp(buf, "vuln") == 0) { abort(); }
}

int main(int argc, char **argv) {
  FILE *file = stdin;
  if (argc > 1) { file = fopen(argv[1], "rb"); }

  // The following three lines are for normal fuzzing.
  /*
  char buf[16];
  char* p = fgets(buf, 16, file);
  buf[15] = 0;
  */

  // The following line is also needed for shared memory testcase fuzzing
  unsigned char *buf = __AFL_FUZZ_TESTCASE_BUF;

  printf("input: %s\n", buf);
  if (buf[0] == 'b') {
    if (buf[1] == 'a') {
      if (buf[2] == 'd') { abort(); }
    }
  }
  vuln(buf);

  return 0;
}




```

注意其中有几个宏用来进行AFL测试
# Opt Parser
这里用到了clap库

```rs
use clap::Parser;
use std::path::PathBuf;
use nix::sys::signal::Signal;


#[derive(Debug, Parser)]
#[command(
    name = "forkserver_simple",
    about = "This is a simple forkserver_test",
    author = "peiwithhao <peiwithhao@outlook.com>",
)]
struct Opt {
    #[arg(
        help = "target to fuzz",
        name = "EXEC",
        required = true
    )]
    executable: String,

    #[arg(
        help = "The directory for initial inputs",
        name = "INPUT_DIR",
        required = true
    )]
    in_dir: PathBuf,

    #[arg(
        help = "Timeout for each individual execution",
        short = 't',
        long = "timeout",
        // in milliseconds
        default_value = "1200"
    )]
    timeout: u64,

    
    #[arg(
        help = "If not set , child's stdout/stderror will be redirect to the /dev/null",
        short = 'd',
        long = "debug-child",
        // in milliseconds
        default_value = "false"
    )]
    debug_child: bool,

    #[arg(
        help = "Arguments passed to the target",
        name = "arguments",
        num_args(1..),
        allow_hyphen_values = true,
    )]
    arguments: Vec<String>,

    #[arg(
        help = "Signal used to stop child",
        short = 's',
        long = "signal",
        value_parser = str::parse::<Signal>,
        default_value = "SIGKILL"
    )]
    signal: Signal,

}

// 定义
fn main() {
    let opt = Opt::parse();
}
```

# Corpus
初始化语料库的选择与编写,可以直接从opt获取
```rs
    let corpus_dirs: Vec<PathBuf> = [opt.in_dir].to_vec();
```

# Shmem
这里的覆盖率Map需要我们创建Shmem来实现，一般步骤为
1. 创建shmem provider
2. 使用`shmem_provider`创建shmem
3. 写入环境变量来让forkserver知道共享内存在哪儿

```rs

    let mut shmem_provider = UnixShMemProvider::new().unwrap();
    let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap();
    unsafe {
        shmem.write_to_env("__AFL_SHM_ID").unwarp();
    }
```

# Observer
创建观察者，观察者的职能就是搜集执行过程中的数据，以备后面的feedback或者objective等组件使用

本次实验使用的观察者如下

```rs

    //这个追踪者用来追踪共享内存覆盖图
    let edges_observer = unsafe {
        HitcountsMapObserver::new(StdMapObserver::new("shared_mem", shmem_buf)).track_indices()
    };
    //这个观察者用来追踪执行时间
    let time_observer = TimeObserver::new("time");
```




# feedback/objective
反馈用来进一步测试

```rs

    //用来评估是否有趣,只要一个feedback觉得有趣就行
    let mut feedback = feedback_or!(
        //需要和历史state进行比较
        MaxMapFeedback::new(&edges_observer),
        //只需要判断时间是否异常就行
        TimeFeedback::new(&time_observer)
        );

    //用来判断是否是solution, 需要同时满足才行
    let mut objective = feedback_and_fast!(
        CrashFeedback::new(),
        MaxMapFeedback::with_name("mapfeedback_metadata_objective", &edges_observer)
        );
```
这里的规则如下：
对于feedback:
1. 满足出现新的边或者时间运行异常则判断为有趣，加入测试用例

对于objective:
1. 同时满足程序crash并且出现新的边则判断为solution

# State
这里的state和正常的并无太大区别

```rs

    //用来判断是否是solution, 需要同时满足才行
    let mut objective = feedback_and_fast!(
        CrashFeedback::new(),
        MaxMapFeedback::with_name("mapfeedback_metadata_objective", &edges_observer)
        );

    let mut state = StdState::new(
        //RNG
        StdRand::with_seed(current_nanos()),
        //内存的Corpus, 用来加快fuzz进程
        InMemoryCorpus::<BytesInput>::new(),
        //保存为solutions的Cropus
        OnDiskCorpus::new(PathBuf::from('./crashes')).unwrap(),
        //feedbak
        &mut feedback,
        //objective
        &mut objective
        ).unwrap();
```

# Monitor/EventManager

用来打印/通知用户测试的详细情况
```rs

    //定义monitor来回显用户
    let monitor = SimpleMonitor::new(|s| println!("{s}"));

    let mut mgr = SimpleEventManager::new(monitor);
```
# Scheduler
从corpus中调度测试用例

```rs

    // 最小+队列 作为从语料库获取测试用例的策略
    let scheduler = IndexesLenTimeMinimizerScheduler::new(&edges_observer, QueueScheduler::new());
```

# fuzzer
```rs

    // 整合调度策略，feedback和objective
    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
```

# executor

用来定义程序的执行逻辑

```rs

    // 查看是否需要查看子进程报错
    let debug_child = opt.debug_child;

    // 为forkserver创建executor
    let args: Vec<String> = opt.arguments;

    //获取句柄用来在下文动态调整bitmap大小
    let observer_ref = edges_observer.handle();

    let mut tokens = Tokens::new();
    let mut executor = ForkserverExecutor::builder()
        .program(opt.executable)
        .debug_child(debug_child)
        .shmem_provider(&mut shmem_provider)
        .autotokens(&mut tokens)
        .parse_afl_cmdline(args)
        .coverage_map_size(MAP_SIZE)
        .timeout(Duration::from_millis(opt.timeout))
        .kill_signal(opt.signal)
        .build(tuple_list!(time_observer, edges_observer))
        .unwrap();

    if let Some(dynamic_map_size) = executor.coverage_map_size(){
        //获取edges_observer的bitmap大小并且动态调整他
        executor.observers_mut()[&observer_ref]
            .as_mut()
            .truncate(dynamic_map_size);
    }
```
# mutator
用来指导变异
```rs
    let mutator = HavocScheduledMutator::with_max_stack_pow(havoc_mutations().merge(tokens_mutations()), 6);
```
这里是将两种变异策略结合，并且指定了迭代次数


# 执行
最后使用`fuzzer.fuzz_loop()`来执行整个测试过程


> [!CAUTION]
> 注意如果出现包的重复依赖，可以使用`cargo tree -i nix`这类来排除问题




