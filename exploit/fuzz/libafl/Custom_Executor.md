# 定制executor
既然AFL++将自身肢解为各大组件作为库来让我们使用，那么其中必定有一定的意义
那么对于库函数的定制化来满足自身特定目标的要求库的优势

这里其他组件基本和`baby_fuzzer`类似,我将解释其中所调用的不同组件


## Executor组件



```rust
struct CustomExecutor<S> {
    phantom: PhantomData<S>,
}

impl<S> CustomExecutor<S> {
    pub fn new(_state: &S) -> Self {
        Self {
            phantom: PhantomData,
        }
    }
}
```

操作解释如下:

1. 这里定义了新的泛型结构体 `struct CustomExecutor<S>` 
2. 结构体内部定义了一个名为`phantom`的变量，类型为`PhantomData<S>`
这个类型仅仅是一个标识当前结构类型的变量，不占用空间,
这里加上只是为了让编译器维护结构体和<T>之间的关联,减少报错

然后为这个结构体实现`Executor`的特性
```sh

impl<EM, I, S, Z> Executor<EM, I, S, Z> for CustomExecutor<S>
where
    S: HasCorpus<I> + HasExecutions,
    I: HasTargetBytes,
{
    fn run_target(
        &mut self,
        _fuzzer: &mut Z,
        state: &mut S,
        _mgr: &mut EM,
        input: &I,
    ) -> Result<ExitKind, libafl::Error> {
        // We need to keep track of the exec count.
        *state.executions_mut() += 1;

        let target = input.target_bytes();  
        let buf = target.as_slice();
        signals_set(0);
        if !buf.is_empty() && buf[0] == b'a' {
            signals_set(1);
            if buf.len() > 1 && buf[1] == b'b' {
                signals_set(2);
                if buf.len() > 2 && buf[2] == b'c' {
                    return Ok(ExitKind::Crash);
                }
            }
        }
        Ok(ExitKind::Ok)
    }
}
```
这里为CustomExecutor添加了`Executor`特性，实现`runs_target`,
where关键字是对于其泛型参数的约束

在main函数里面的声明如下
```rust
    let executor = CustomExecutor::new(&state);
    let mut executor = WithObservers::new(executor, tuple_list!(observer));
```
将CustomExecutor和Observer进行了整合



## Objective组件
该组件用来决定solution
```rust
    /* 使用feedback_and_fast!宏来创建一个链式的objective对象，用来容纳多个种类的observer */
    let mut objective = feedback_and_fast!(
        CrashFeedback::new(),
        MaxMapFeedback::with_name("on_crash", &observer)
        );

```
这里定义了多个定义为solution的方案



## Stage组件
这里定义了多个Stage，
```rust

    let calibration_stage = CalibrationStage::new(&feedback);
    let stats_stage = AflStatsStage::builder()
        .map_observer(&observer)
        .build()
        .unwrap();

    let mutator = HavocScheduledMutator::new(havoc_mutations());

    let mut stages = tuple_list!(
        calibration_stage,
        StdMutationalStage::new(mutator),
        stats_stage
        );
```

当他处理测试用例的时候会按照顺序来执行这些Stage
其中`CalibrationStage`解释入下:
> [!NOTE]
> The calibration stage will measure the average exec time and the target’s stability for this input.
而`AflStatsStage`解释入下

> [!NOTE]
> The AflStatsStage is a Stage that calculates and writes AFL++’s fuzzer_stats and plot_data information.


# 总结
本次所学习到的知识
1. 自己定义结构体并实现Executor特性，
2. 多个objective,用来判断solutions
3. 多个stage,用来处理输入




